1
00:00:00,120 --> 00:00:04,730
Hey guys, welcome to Day 26 of 100 Days of Code. Today

2
00:00:04,820 --> 00:00:08,480
we're going to be learning all about lists and dictionary comprehensions.

3
00:00:08,900 --> 00:00:12,500
This is something that's actually really unique to the Python language,

4
00:00:12,890 --> 00:00:16,970
and it's something that's going to cut down on a lot of the code that we have to

5
00:00:16,970 --> 00:00:20,030
write when we're working with lists and dictionaries.

6
00:00:20,630 --> 00:00:22,100
And by the end of today,

7
00:00:22,280 --> 00:00:27,260
we will build a project to use the NATO phonetic alphabets so that

8
00:00:27,260 --> 00:00:31,490
we can spell out various things on the telephone. For example,

9
00:00:31,490 --> 00:00:33,920
whenever you need to give your name and you have to spell it out,

10
00:00:34,220 --> 00:00:36,260
they might not hear which letter you said.

11
00:00:36,320 --> 00:00:38,840
So normally you'll say something like A

12
00:00:38,840 --> 00:00:41,450
for alpha, n for november, g for golf.

13
00:00:41,930 --> 00:00:46,550
This is what we're aiming to create; a program that works in the console

14
00:00:46,910 --> 00:00:51,350
and it allows us to enter a word. So for example, I just put in my name

15
00:00:51,410 --> 00:00:55,310
which I happen to have to spell on the phone many times and I hit enter,

16
00:00:55,550 --> 00:01:00,550
then it'll return a list of all of the NATO phonetic alphabet that matches each

17
00:01:00,980 --> 00:01:02,810
of the letters in my name

18
00:01:03,020 --> 00:01:06,440
so I can just read it out to the other person over the phone, alpha,

19
00:01:06,440 --> 00:01:08,570
november, golf, echo, Lima, alpha.

20
00:01:09,290 --> 00:01:13,580
And that way I can use this little tool and be able to spell any word I want

21
00:01:13,820 --> 00:01:16,160
easily using the NATO phonetic alphabet.

22
00:01:16,400 --> 00:01:21,350
So I hope you're excited to learn about this big topic of comprehensions, and

23
00:01:21,380 --> 00:01:24,620
once you're ready, head over to the next lesson, and let's get started.


24
00:00:00,480 --> 00:00:05,480
The big topic that we're going to explore today is a concept known as a list

25
00:00:05,970 --> 00:00:08,850
comprehension. And as I mentioned before,

26
00:00:08,850 --> 00:00:11,880
this is something that's really unique to the Python language.

27
00:00:12,210 --> 00:00:13,980
In many other programming languages,

28
00:00:14,010 --> 00:00:17,490
you don't actually have access to something like this.

29
00:00:17,520 --> 00:00:19,500
There's nothing that really compares to it.

30
00:00:19,830 --> 00:00:22,350
And it's something that Python developers really,

31
00:00:22,350 --> 00:00:26,820
really love because it cuts down on the amount of typing and it just makes the

32
00:00:26,820 --> 00:00:30,840
code a lot shorter, and in most cases, a lot easier to read.

33
00:00:31,520 --> 00:00:36,410
So what exactly is a list comprehension? Well, it's a case where you 

34
00:00:36,410 --> 00:00:36,770
create

35
00:00:36,770 --> 00:00:41,770
a new list from a previous list. So far we've been doing that using for loops.

36
00:00:42,200 --> 00:00:45,830
So for example, if I have a list of numbers, 1, 2, 3,

37
00:00:46,280 --> 00:00:51,280
and I want to create a new list where each number is increased by one,

38
00:00:52,370 --> 00:00:52,520
well

39
00:00:52,520 --> 00:00:57,260
then I would use a for loop creating a new empty list and then looping through

40
00:00:57,350 --> 00:01:01,670
each of the numbers in that list in order to add one to

41
00:01:01,700 --> 00:01:02,810
each of those numbers.

42
00:01:03,170 --> 00:01:08,170
And then I would append each of those increased numbers to my new list.

43
00:01:08,870 --> 00:01:13,100
And I would end up with a new list that consists of three items,

44
00:01:13,370 --> 00:01:17,810
and it will be 2, 3, and 4. Now using list comprehension

45
00:01:17,900 --> 00:01:22,520
we can take these four lines of code and turn it into one.

46
00:01:23,060 --> 00:01:27,740
And the way that we create a list comprehension looks something like this.

47
00:01:28,340 --> 00:01:32,450
I like to use the keyword method where you type out the list comprehension

48
00:01:32,450 --> 00:01:33,283
keywords,

49
00:01:33,530 --> 00:01:38,390
and then replace each of the words with the actual item in your code.

50
00:01:39,170 --> 00:01:43,520
The way that we would create any list comprehension is we will create the name

51
00:01:43,550 --> 00:01:48,550
of the new list and instead of creating a empty list and then having to append

52
00:01:49,040 --> 00:01:53,420
to it or populate it, we actually going to create it straight in the same line.

53
00:01:53,840 --> 00:01:58,220
So we open up a set of square brackets to denote that we're creating a new list,

54
00:01:58,640 --> 00:02:03,170
and then we have this new _item for item in list

55
00:02:03,320 --> 00:02:06,020
keyword pattern. Here's how it would work.

56
00:02:06,050 --> 00:02:08,419
Let's take that same thing that we did before

57
00:02:08,660 --> 00:02:10,520
where we took you a list of numbers

58
00:02:10,580 --> 00:02:14,240
and we created a new list where each number is increased by one,

59
00:02:14,480 --> 00:02:17,300
and let's see how we would do it using list comprehension.

60
00:02:18,590 --> 00:02:22,040
So the first keyword I'm going to replace is the list.

61
00:02:22,280 --> 00:02:26,210
So this is the list that we're going to iterate through. And in our case,

62
00:02:26,240 --> 00:02:30,110
it's this list of numbers. So let's replace that list

63
00:02:30,110 --> 00:02:33,440
keyword with the actual list, which is numbers.

64
00:02:34,010 --> 00:02:38,210
The next thing that is easy to understand is each item in the list.

65
00:02:38,210 --> 00:02:41,600
So we can call this anything we want. In the for loop here,

66
00:02:41,600 --> 00:02:46,190
we called it n, so why don't we go ahead and call it n again?

67
00:02:47,870 --> 00:02:52,700
This n is going to represent each of the numbers in that list of numbers

68
00:02:52,760 --> 00:02:54,740
just as it does in this for-loop.

69
00:02:55,460 --> 00:02:59,590
And the final keyword that we haven't yet replaced is the new_item.

70
00:03:00,010 --> 00:03:04,270
So what do we want each of the new items to be in this new list?

71
00:03:04,690 --> 00:03:05,200
Well,

72
00:03:05,200 --> 00:03:10,200
each of the new items is basically calculated by taking n and then adding one

73
00:03:10,750 --> 00:03:11,500
to it.

74
00:03:11,500 --> 00:03:16,500
So this line is the expression or the code that we need to execute in order to

75
00:03:17,560 --> 00:03:21,910
get a new_item. So this becomes our final list

76
00:03:21,910 --> 00:03:25,060
comprehension. We have our lists of numbers

77
00:03:25,150 --> 00:03:29,620
and then we create a new list where we loop through each of the numbers, n,

78
00:03:29,950 --> 00:03:31,750
inside this list of numbers

79
00:03:32,080 --> 00:03:37,080
and then for each of the n, we add one to it in order to create the final list.

80
00:03:37,570 --> 00:03:42,310
So when you look at a list comprehension just like this as in the real code,

81
00:03:42,610 --> 00:03:45,700
it can be a little bit confusing to see how would you read it,

82
00:03:45,730 --> 00:03:47,260
which order does it happen.

83
00:03:47,620 --> 00:03:50,920
But when you're using this keyword method that I often use

84
00:03:50,920 --> 00:03:55,240
where you just type out what you need to have inside a list comprehension,

85
00:03:55,240 --> 00:03:58,390
you need a name for the new list, you need a set of square brackets

86
00:03:58,660 --> 00:04:02,680
and then inside the square brackets, you have new_item for item in list.

87
00:04:03,010 --> 00:04:07,390
Then you go through it replacing each of the keywords, list item

88
00:04:07,390 --> 00:04:12,340
and new_item. So I want you to have a go at actually writing out this code.

89
00:04:12,640 --> 00:04:15,310
Go ahead and create a new PyCharm project,

90
00:04:15,670 --> 00:04:18,220
and I want you to go into the Python console.

91
00:04:18,700 --> 00:04:21,940
We're not actually going to be writing code inside our main.py.

92
00:04:22,300 --> 00:04:26,770
And the reason is because the console allows us to write code line by line

93
00:04:27,070 --> 00:04:31,150
and then we can view our variables really easily on the right-hand side pane

94
00:04:31,150 --> 00:04:35,650
here. For example, if I have my list of numbers, 1, 2, 3,

95
00:04:36,130 --> 00:04:39,310
and then I have to write out my list comprehension

96
00:04:39,340 --> 00:04:42,610
where we create our new list which I'll call new_numbers,

97
00:04:43,150 --> 00:04:46,510
and then we have to create our list comprehension.

98
00:04:46,600 --> 00:04:51,600
So the way to remember it is new_item for item in list.

99
00:04:52,660 --> 00:04:57,660
So now go ahead and write this out and see if you can remember how we actually

100
00:04:58,150 --> 00:05:02,830
structure our list comprehension and see if you can get it to work within your

101
00:05:02,830 --> 00:05:06,340
PyCharm console. So pause the video, give that a go.

102
00:05:08,170 --> 00:05:11,500
All right. So our list is of course, this list of numbers.

103
00:05:11,530 --> 00:05:13,180
So let's replace that first.

104
00:05:13,660 --> 00:05:16,930
And then for each of the items in that list of numbers, well,

105
00:05:16,930 --> 00:05:21,070
we can call it anything we want. So I'm just going to call it n or num,

106
00:05:21,310 --> 00:05:25,300
it doesn't matter. But as long as you're consistent in using it

107
00:05:25,540 --> 00:05:26,950
when you create the new item

108
00:05:27,340 --> 00:05:30,670
because each new item is going to be the n,

109
00:05:30,730 --> 00:05:34,210
which is each number in the list, +1.

110
00:05:34,750 --> 00:05:36,400
So now when I hit enter,

111
00:05:36,460 --> 00:05:41,410
you can see I've got this new list called new_numbers created from the previous

112
00:05:41,410 --> 00:05:45,550
list, numbers, and this now has the same number of items

113
00:05:45,580 --> 00:05:48,160
but each item is now increased by one.

114
00:05:49,480 --> 00:05:52,960
Now it's important to remember that when we say list comprehension,

115
00:05:53,200 --> 00:05:56,680
it doesn't strictly mean that you can only work with list.

116
00:05:56,930 --> 00:06:00,710
You can work with other sequences like strings, for example.

117
00:06:00,950 --> 00:06:05,630
So here I've got a variable called name, which is just a string. It's the word

118
00:06:05,690 --> 00:06:06,523
Angela.

119
00:06:06,770 --> 00:06:11,770
And I'm creating a new list by using a list comprehension that has this kind of

120
00:06:13,520 --> 00:06:14,510
code. Now,

121
00:06:14,510 --> 00:06:19,510
I want you to pause for a second and think about what would be in this new list,

122
00:06:19,610 --> 00:06:24,050
what would it look like? And then I want you to try it out inside PyCharm.

123
00:06:24,350 --> 00:06:28,460
So pause the video now. All right.

124
00:06:28,460 --> 00:06:32,900
So name equals Angela, this is the variable that we're working with.

125
00:06:33,500 --> 00:06:35,630
And then I'm going to create a new list

126
00:06:35,720 --> 00:06:39,290
which I'll call letters_list.

127
00:06:40,550 --> 00:06:44,600
This new list is going to be created using my list comprehension.

128
00:06:44,990 --> 00:06:49,990
So it's going to be letter for letter in name. And what this does is it takes

129
00:06:53,510 --> 00:06:56,330
this sequence, this string,

130
00:06:56,780 --> 00:06:59,750
it goes through each of the letters in that string

131
00:07:00,230 --> 00:07:04,640
and then it adds each of the letters into this new list.

132
00:07:05,060 --> 00:07:08,210
So when I hit enter, you can see, this is what letters_list

133
00:07:08,210 --> 00:07:13,010
looks like. It's just split off my string into individual letters

134
00:07:13,280 --> 00:07:15,950
and it's added it into a brand new list.

135
00:07:17,390 --> 00:07:20,390
As I mentioned, these things in Python

136
00:07:20,390 --> 00:07:25,390
like a list or a string or a range or tuple, they're called sequences because

137
00:07:27,800 --> 00:07:32,630
they have a specific order. And when you perform a list comprehension,

138
00:07:32,660 --> 00:07:37,280
it's going to take that sequence and it's going to go through it in order either

139
00:07:37,280 --> 00:07:41,870
be it the letters in the string or the items in a list.

140
00:07:42,230 --> 00:07:46,280
And then it's going to take each of those items in that correct order

141
00:07:46,490 --> 00:07:50,450
and then do something with it, either add one to it, or in this case,

142
00:07:50,450 --> 00:07:54,650
do nothing and just add it to a new list. Here's a challenge for you.

143
00:07:55,010 --> 00:07:56,720
Can you take the range,

144
00:07:56,750 --> 00:08:01,670
which is also a sequence that we can iterate through, and then create a range

145
00:08:01,670 --> 00:08:03,440
between 1 and 5?

146
00:08:03,800 --> 00:08:07,940
And remember that the way that the range works is it's going to take 1 and

147
00:08:07,940 --> 00:08:12,590
then 2, and then 3 and then 4, but it's not going to go up to 5.

148
00:08:13,070 --> 00:08:17,630
I want you to loop through this range and then create a list where each of the

149
00:08:17,630 --> 00:08:20,630
numbers in the range is doubled.

150
00:08:21,170 --> 00:08:25,760
And the final list should look like this. It will be 2, 4, 6,

151
00:08:25,820 --> 00:08:29,780
and 8. Pause the video and see if you can complete this challenge.

152
00:08:32,450 --> 00:08:34,730
All right. So let's create our new lists

153
00:08:34,760 --> 00:08:37,039
which I'm just going to call range_list.

154
00:08:37,429 --> 00:08:40,340
And we're going to use that keyword pattern to remind ourselves.

155
00:08:40,610 --> 00:08:44,570
So it was going to be new_item for item in list.

156
00:08:45,110 --> 00:08:48,380
And this list, in this case, is actually not going to be a list,

157
00:08:48,380 --> 00:08:50,810
it is going to be a range between 1 and 5.

158
00:08:51,320 --> 00:08:55,220
And then each of the items, we get to give it a name, which I'll just call num.

159
00:08:55,710 --> 00:09:00,510
And then in this new list, what is each new item going to be? Well,

160
00:09:00,510 --> 00:09:05,040
it's going to be num multiplied by 2. So now when I hit enter,

161
00:09:05,070 --> 00:09:08,640
I get my range_list, which is 2, 4, 6, 8.

162
00:09:09,030 --> 00:09:11,760
So its loop through each of the numbers in the range

163
00:09:11,940 --> 00:09:14,340
and its multiplied each of those numbers by 2,

164
00:09:14,670 --> 00:09:18,750
and then its created a new list using each of those numbers.

165
00:09:19,920 --> 00:09:24,420
Now the final thing I want to show you regarding list comprehensions is that

166
00:09:24,420 --> 00:09:28,590
there's also such a thing as a conditional list comprehension.

167
00:09:29,010 --> 00:09:31,860
This takes our keywords a little bit further.

168
00:09:31,880 --> 00:09:35,030
Whereas previously we stopped right here,

169
00:09:35,900 --> 00:09:40,730
new_item for item in list. We can also tag on two more keywords;

170
00:09:40,850 --> 00:09:42,410
if and a test.

171
00:09:43,070 --> 00:09:48,070
What this is going to allow us to do is to only add this new item and only to

172
00:09:48,800 --> 00:09:53,660
perform this code if the test actually passes.

173
00:09:54,920 --> 00:09:59,780
Here's an example. I've got a bunch of names here; Alex, Beth, Caroline,

174
00:09:59,780 --> 00:10:02,120
Dave, Eleanor, and Freddy. Now,

175
00:10:02,120 --> 00:10:06,980
one of the neat things that you can actually do with the Python console is not

176
00:10:06,980 --> 00:10:10,160
only can you view what all of the variables are equal to,

177
00:10:10,370 --> 00:10:12,530
but you can also edit them if you have an issue.

178
00:10:13,010 --> 00:10:17,300
The sharp-eyed amongst you will know that I've actually made a typo in this

179
00:10:17,300 --> 00:10:21,800
name, it's not Elanor, its actually spelled a little bit differently.

180
00:10:22,280 --> 00:10:27,020
So what I can do on the right-hand pane here is I can right-click on that piece

181
00:10:27,020 --> 00:10:30,860
of data that I want to change and then click set value,

182
00:10:31,280 --> 00:10:33,740
and then actually change the data here.

183
00:10:35,120 --> 00:10:39,530
Now that I've got that spelled out correctly, if I type names and hit enter,

184
00:10:39,770 --> 00:10:44,360
you can see it's now been corrected and this is my new list of names.

185
00:10:45,170 --> 00:10:46,820
So using this list of names,

186
00:10:47,180 --> 00:10:50,030
I'm going to try and create a new list of names,

187
00:10:50,360 --> 00:10:52,460
but I only want the short names.

188
00:10:52,550 --> 00:10:57,550
I only want the names which is made up of four letters or less, like Alex or

189
00:10:57,620 --> 00:10:58,453
Beth.

190
00:10:58,700 --> 00:11:02,750
The way I would do this is I would create a new list,

191
00:11:02,780 --> 00:11:06,530
which is called short_names. And then I would use my list comprehension.

192
00:11:06,800 --> 00:11:11,720
And remember, in this case, the keywords are new_item

193
00:11:11,810 --> 00:11:16,550
for item in list. And then if and a test.

194
00:11:17,540 --> 00:11:19,670
So let's fill in the easy parts first.

195
00:11:20,060 --> 00:11:24,290
The list is going to be our list of names, the item I can call it

196
00:11:24,290 --> 00:11:29,210
anything I want. I'll just call it name in terms of the singular form of names.

197
00:11:29,720 --> 00:11:33,770
And then once I loop through each of the names inside my list of names,

198
00:11:34,100 --> 00:11:38,090
what is the new item going to be? Well, it's actually going to be unmodified.

199
00:11:38,090 --> 00:11:42,350
It's just going to be that same name. But in this case,

200
00:11:42,380 --> 00:11:46,940
I'm only going to add that name to the list if it passes this test.

201
00:11:47,540 --> 00:11:51,140
And this test is going to look at the length of the name

202
00:11:51,260 --> 00:11:53,030
which I created here,

203
00:11:53,290 --> 00:11:57,940
so if I named this n then I would be testing it against n and it would be adding

204
00:11:57,940 --> 00:12:01,060
n as well. But because I've called it name

205
00:12:01,060 --> 00:12:04,300
so I'm going to use that name right here in the condition.

206
00:12:04,810 --> 00:12:07,900
So if the length of the name is less than five,

207
00:12:08,230 --> 00:12:11,620
so it has four or less characters,

208
00:12:12,370 --> 00:12:17,350
then I'm going to add that name to my new list. Now, when I hit enter,

209
00:12:17,710 --> 00:12:22,710
you can see that I've got this new list of short names and it only contains the

210
00:12:22,870 --> 00:12:24,970
names, Alex, Beth and Dave.

211
00:12:25,630 --> 00:12:30,580
So this list comprehension is now a little bit more complex because the first

212
00:12:30,580 --> 00:12:35,580
thing it does is it goes through each of the names inside this list of names,

213
00:12:36,100 --> 00:12:41,080
it checks each of those names for its length. And if the length is five,

214
00:12:41,350 --> 00:12:44,530
then it adds the name to this new list.

215
00:12:46,180 --> 00:12:47,620
Now here's a challenge for you.

216
00:12:48,130 --> 00:12:52,120
I want you to take all of the names from this list of names

217
00:12:52,570 --> 00:12:57,340
which are made up of five letters or more, so basically Caroline,

218
00:12:57,370 --> 00:12:58,720
Eleanor and Freddie,

219
00:12:59,050 --> 00:13:04,050
and I want you to turn each of these names to the uppercase version.

220
00:13:04,720 --> 00:13:09,720
What you should end up with is a list where you have CAROLINE in all caps,

221
00:13:10,960 --> 00:13:15,430
ELEANOR in all caps and FREDDIE in all caps.

222
00:13:15,670 --> 00:13:17,470
But of course, you're not going to just type this out,

223
00:13:17,470 --> 00:13:19,420
you're going to use list comprehension.

224
00:13:19,930 --> 00:13:22,900
Pause the video and see if you can complete this challenge.

225
00:13:25,060 --> 00:13:27,790
All right. I'm going to call this new list long_names,

226
00:13:27,820 --> 00:13:32,170
cause I haven't eaten for a while and I lack imagination. Now,

227
00:13:32,260 --> 00:13:34,450
in order to create this list of long names,

228
00:13:34,510 --> 00:13:37,450
I'm going to use that new keyword pattern that we learned,

229
00:13:37,780 --> 00:13:41,530
which is new item for item in list

230
00:13:41,800 --> 00:13:46,300
if test. The list is, again, going to be our list of names.

231
00:13:46,780 --> 00:13:49,540
Each of the items we can call it anything we want,

232
00:13:49,690 --> 00:13:54,430
but I'm going to call it name. And if you find that this is too similar to this,

233
00:13:54,700 --> 00:13:55,870
you can call anything you want.

234
00:13:55,900 --> 00:14:00,900
Nom, you can use French or you can just write n or you can do anything you want.

235
00:14:02,830 --> 00:14:07,830
This name that we're looping through is going to be tested in order to see if

236
00:14:08,350 --> 00:14:10,120
we're actually going to create a new item.

237
00:14:10,600 --> 00:14:15,600
So the test, in this case, is we're checking to see if the length of the name is

238
00:14:15,760 --> 00:14:17,290
now greater than five.

239
00:14:19,090 --> 00:14:23,890
And if this name that we're currently looping through passes this test,

240
00:14:24,160 --> 00:14:27,340
then we get to specify what the new item should be.

241
00:14:27,940 --> 00:14:31,870
So the new item is going to be that particular name that passed the test,

242
00:14:32,260 --> 00:14:34,060
but then it's going to be uppercased,

243
00:14:34,360 --> 00:14:38,950
so we're going to call name.upper in order to create the new item

244
00:14:38,980 --> 00:14:42,850
that's going to be added to the list. So now once I hit enter,

245
00:14:43,030 --> 00:14:47,770
you can see the new list that I've created, long_names, has Caroline,

246
00:14:47,800 --> 00:14:50,920
Eleanor and Freddy, all in uppercase.

247
00:14:51,560 --> 00:14:54,770
Essentially, we looped through each of the names in the list,

248
00:14:55,010 --> 00:14:58,370
we took each of those names and checked that they'ree longer than five.

249
00:14:58,760 --> 00:15:00,860
If they were, in fact, longer than five,

250
00:15:00,920 --> 00:15:04,640
then we looked at this part of the code to see what we should do with each of

251
00:15:04,640 --> 00:15:07,910
those names. And in our case, we've turned it into uppercase.

252
00:15:08,600 --> 00:15:12,020
So there's quite a lot of theory covered in today's lesson.

253
00:15:12,320 --> 00:15:15,260
And if you want to see the code that I've been writing so far,

254
00:15:15,530 --> 00:15:20,420
then you can always head over to the day-26-end Repl.it in order to either

255
00:15:20,420 --> 00:15:25,310
download it or just read through the code that I've been typing. Now,

256
00:15:25,340 --> 00:15:27,800
in order to be able to fully understand what's going on,

257
00:15:28,010 --> 00:15:31,580
you can't just watch me talk about it. You have to practice.

258
00:15:31,850 --> 00:15:33,230
So in the coming lessons,

259
00:15:33,260 --> 00:15:38,090
I've got a whole bunch of exercises for you to practice using and creating list

260
00:15:38,090 --> 00:15:41,480
comprehensions for yourself. And that way, once you've done the drills,

261
00:15:41,750 --> 00:15:45,050
you've done the code press-ups, then you'll be able to show off your list

262
00:15:45,050 --> 00:15:49,490
comprehension muscles. For all of that and more, I'll see you on the next lesson.


263
00:00:00,870 --> 00:00:05,250
Now it's time to put what you've learned into practice and to actually learn

264
00:00:05,250 --> 00:00:10,250
through doing. So if you go to Repl.it where you are going to go to day 26.1 List

265
00:00:11,520 --> 00:00:16,050
Comprehension, and you're going to complete this challenge. So pause the video,

266
00:00:16,379 --> 00:00:17,100
head over there,

267
00:00:17,100 --> 00:00:20,370
read the instructions and see if you can complete the challenge.

268
00:00:20,760 --> 00:00:23,940
Once you're done, head back over here and I'll go through the solution with you.

269
00:00:26,400 --> 00:00:27,720
All right. So in this case,

270
00:00:27,780 --> 00:00:32,460
what we're trying to do is we're taking this list of numbers and we're basically

271
00:00:32,460 --> 00:00:36,750
going to write a single line of code here to change it

272
00:00:36,960 --> 00:00:41,670
so that we end up with a new list where each number is squared.

273
00:00:42,090 --> 00:00:45,570
A square number is basically just the number multiplied by itself.

274
00:00:45,990 --> 00:00:50,280
So for example, four squared is sixteen, two squared is four,

275
00:00:50,310 --> 00:00:54,930
three squared is nine. So let's go ahead and create our new list

276
00:00:55,290 --> 00:00:57,690
which it needs to be called squared numbers,

277
00:00:57,720 --> 00:00:59,310
because that's what we're going to print out.

278
00:00:59,370 --> 00:01:02,130
And that's what the automated testing is going to be looking for.

279
00:01:02,700 --> 00:01:07,620
This new list is going to be created using a list comprehension,

280
00:01:07,920 --> 00:01:09,990
so we're going to use our keyword method,

281
00:01:10,440 --> 00:01:14,400
new_item for item in list.

282
00:01:14,970 --> 00:01:19,020
And in this case, we actually don't need to do any conditional checking.

283
00:01:19,050 --> 00:01:21,750
We're taking every single one of these items,

284
00:01:22,050 --> 00:01:25,740
so this is the keyword that we need to fill in. The list,

285
00:01:25,740 --> 00:01:29,520
in this case, is our list of numbers. Each of the items,

286
00:01:29,520 --> 00:01:32,340
we can call it anything we want, but I'm going to call it num.

287
00:01:32,790 --> 00:01:35,820
And this new item is going to be num,

288
00:01:35,880 --> 00:01:39,750
so each of the items in that list, multiplied by itself.

289
00:01:40,110 --> 00:01:44,490
You can either do it like this which will get you the output that you need.

290
00:01:44,820 --> 00:01:48,930
Alternatively, you can use Python's built in exponents,

291
00:01:49,170 --> 00:01:52,350
which is just num**2.

292
00:01:52,680 --> 00:01:57,510
And this will square that number, which will give you exactly the same results.

293
00:01:58,080 --> 00:02:01,110
Now, you're ready to head over to the next lesson where we've got 

294
00:02:01,110 --> 00:02:03,120
another list comprehension exercise.


295
00:00:00,150 --> 00:00:02,850
All right. Let's keep working while our brain muscles are hot.

296
00:00:03,450 --> 00:00:06,720
Now we're going to go over to day 26.2,

297
00:00:07,020 --> 00:00:09,690
our second list comprehension exercise.

298
00:00:10,260 --> 00:00:12,120
So head over there, pause the video,

299
00:00:12,120 --> 00:00:16,170
read through the instructions and try to complete the code exercise.

300
00:00:16,860 --> 00:00:19,860
I'll see you on the other side where we'll go through the solution together.

301
00:00:20,250 --> 00:00:24,750
Pause the video now. Okay.

302
00:00:24,750 --> 00:00:26,280
So in this exercise,

303
00:00:26,430 --> 00:00:29,970
what we're trying to do is we're going to take this list of numbers

304
00:00:30,420 --> 00:00:31,950
and we're going to write a list

305
00:00:31,950 --> 00:00:34,920
comprehension do create a new list called results.

306
00:00:35,400 --> 00:00:37,950
Now we're only going to need one line of code again,

307
00:00:38,130 --> 00:00:40,650
because we're going to be using a list comprehension.

308
00:00:41,160 --> 00:00:46,140
And what we're going to do with our list comprehension is to take only the

309
00:00:46,140 --> 00:00:50,520
numbers from this list of numbers which has an even number.

310
00:00:51,270 --> 00:00:55,230
We should basically end up with only the two of the eight and thirty four,

311
00:00:55,440 --> 00:00:58,170
because every other number in this list is odd.

312
00:00:58,830 --> 00:01:02,100
We're going to create our results which is on your list,

313
00:01:02,670 --> 00:01:04,470
and then we're going to put in our keywords.

314
00:01:04,860 --> 00:01:09,030
So it's going to be new item for item in list,

315
00:01:09,300 --> 00:01:10,380
and because this time

316
00:01:10,380 --> 00:01:15,000
we're not taking every single item from the original list that we're looping

317
00:01:15,000 --> 00:01:15,600
through,

318
00:01:15,600 --> 00:01:20,460
we're going to need to add a if statement to make a conditional test.

319
00:01:21,900 --> 00:01:23,610
So let's start with the easy thing.

320
00:01:23,790 --> 00:01:26,910
The list that we're going to iterate through is our list of numbers.

321
00:01:27,480 --> 00:01:32,310
Each of the items I'm going to call num, and for each of those numbers,

322
00:01:32,640 --> 00:01:37,290
we're going to test to see if the number modulo by two,

323
00:01:37,560 --> 00:01:41,880
which remember means number divided by two and then get the remainder.

324
00:01:42,330 --> 00:01:45,360
If that remainder is equal to zero, well

325
00:01:45,360 --> 00:01:50,360
then that means that that number is even. If you remember from previously,

326
00:01:51,480 --> 00:01:56,220
we could use modulo to check if a number has any remainder.

327
00:01:56,460 --> 00:01:59,910
So if I do three modulo two,

328
00:02:00,030 --> 00:02:04,920
you can see that it has a remainder of one. But when I do six modular three,

329
00:02:05,100 --> 00:02:08,610
that has no remainder because it can be cleanly divided.

330
00:02:09,150 --> 00:02:11,190
So now that we've tested

331
00:02:11,220 --> 00:02:14,820
if each number modulo two is equal to zero, well

332
00:02:14,820 --> 00:02:17,550
then if that test passes,

333
00:02:17,850 --> 00:02:20,970
then that particular number that passed the test

334
00:02:21,060 --> 00:02:25,260
is going to be welcomed to this new list of results. So now when I hit run,

335
00:02:25,290 --> 00:02:29,760
you can see the result that I get is the same as my expected results.

336
00:02:30,540 --> 00:02:33,840
Now we've got one final list comprehension exercise for you.

337
00:02:33,900 --> 00:02:37,470
So head over to the next lesson and complete the exercise.


338
00:00:00,390 --> 00:00:04,980
All right. So we're now onto our final list comprehension exercise of the day.

339
00:00:05,580 --> 00:00:10,260
And just a word of warning, this exercise is quite hard.

340
00:00:10,710 --> 00:00:15,710
I decided that the previous two were a little bit easier and you've now kind of

341
00:00:15,900 --> 00:00:20,430
warmed up and you've gotten going, it's time to test your knowledge on a number

342
00:00:20,430 --> 00:00:21,330
of things that you've learned.

343
00:00:22,200 --> 00:00:26,970
The first thing I want you to do is take a look at these two files and look at

344
00:00:26,970 --> 00:00:29,340
the structure of the data in there,

345
00:00:29,970 --> 00:00:34,650
and then have a read through the instruction and see if you can complete this

346
00:00:34,680 --> 00:00:35,513
challenge.

347
00:00:35,700 --> 00:00:40,700
This is the output that you are expecting when your new list called result is

348
00:00:40,830 --> 00:00:44,100
printed. Pause the video and give this a go.

349
00:00:47,670 --> 00:00:48,030
All right.

350
00:00:48,030 --> 00:00:53,030
So we know that we've got two text files with a new piece of data on each line.

351
00:00:54,900 --> 00:00:55,440
Essentially,

352
00:00:55,440 --> 00:01:00,390
what we're trying to do here is we're trying to take the data in file1.

353
00:01:00,390 --> 00:01:04,890
txt and compare it against the data in file2.txt,

354
00:01:05,310 --> 00:01:09,750
and then we're trying to get a hold of the data which exists in both of these

355
00:01:09,750 --> 00:01:14,670
files. So if file1 contained one, two, three, file2 contained two,

356
00:01:14,670 --> 00:01:15,503
three, four,

357
00:01:15,690 --> 00:01:20,250
then the result should be a list that contains the overlapping numbers.

358
00:01:20,550 --> 00:01:24,750
Two and three exists in both files. Now,

359
00:01:24,750 --> 00:01:29,370
in order to pass the test, the result must be a list that contains integers,

360
00:01:29,430 --> 00:01:33,180
so whole numbers, not strings. So when you print it out,

361
00:01:33,300 --> 00:01:37,470
if you see the numbers as they are, then that means they are integers.

362
00:01:37,800 --> 00:01:40,560
But if you see quotation marks around each of the numbers,

363
00:01:40,800 --> 00:01:42,450
then they are strings instead.

364
00:01:42,900 --> 00:01:45,990
And our code checking is not going to allow that to pass.

365
00:01:47,190 --> 00:01:52,190
The first thing we need to do is to use our read lines method that we've used

366
00:01:52,320 --> 00:01:57,320
several times before to read the data from each of these files and create a list

367
00:01:57,780 --> 00:02:00,780
from each line. Let's go ahead and do that.

368
00:02:00,990 --> 00:02:05,430
So I'm going to use my with open and I'm going to tap into my file1.

369
00:02:05,430 --> 00:02:09,000
txt, and I'm going to save this as file1.

370
00:02:09,900 --> 00:02:13,710
And then this file is going to be read,

371
00:02:13,950 --> 00:02:16,800
and I'm going to call file1.readlines,

372
00:02:17,220 --> 00:02:22,220
and then I'm going to save this list to a new variable called file_1_data. And

373
00:02:25,260 --> 00:02:27,510
notice how I've actually made a typo here

374
00:02:27,510 --> 00:02:31,680
cause I want file1.txt instead of just file.text.

375
00:02:32,010 --> 00:02:33,120
It's good that I spotted it.

376
00:02:34,320 --> 00:02:39,320
And then we're going to do the same with file2 and change all of the places

377
00:02:39,960 --> 00:02:40,890
where we have one.

378
00:02:41,520 --> 00:02:45,180
So copying and pasting is always a little bit prone to error,

379
00:02:45,360 --> 00:02:47,490
but hopefully we'll manage this time.

380
00:02:48,270 --> 00:02:53,130
Now that I've got file_1_data and file_2_data which are both lists,

381
00:02:53,490 --> 00:02:58,490
I can now think about how I can compare those two and create my new list

382
00:02:59,440 --> 00:03:01,300
which is going to be called result.

383
00:03:02,410 --> 00:03:07,410
Now result is a new list and I'm going to use my full list of keywords

384
00:03:09,010 --> 00:03:12,670
inside this new list to create the list comprehension.

385
00:03:13,000 --> 00:03:17,500
So new item for item in lists if test,

386
00:03:18,340 --> 00:03:23,020
the list that I'm going to test is actually the first list.

387
00:03:23,590 --> 00:03:27,460
I'm going to take the file_1_data which is a list of numbers,

388
00:03:28,090 --> 00:03:33,090
and then I'm going to go through each of the numbers inside this list,

389
00:03:35,350 --> 00:03:37,300
and then I'm going to do a check.

390
00:03:37,900 --> 00:03:42,070
And the check is where this file2 is going to come into play.

391
00:03:42,640 --> 00:03:44,200
So I'm going to check to see, well,

392
00:03:44,290 --> 00:03:48,850
if this number that I'm looping through exists in,

393
00:03:48,880 --> 00:03:50,350
remember the in keyword,

394
00:03:50,620 --> 00:03:54,010
this file_2_data, this other list,

395
00:03:54,340 --> 00:03:58,870
well then I'm going to include this number inside my new list.

396
00:03:59,860 --> 00:04:04,360
So this number is going to go into the new list. At the moment when I hit run,

397
00:04:04,420 --> 00:04:08,170
you can see them getting a whole bunch of strings. So in addition,

398
00:04:08,200 --> 00:04:13,030
I have to modify this number so that I convert it into an integer.

399
00:04:13,510 --> 00:04:17,649
So I end up with the same output as is expected here.

400
00:04:19,390 --> 00:04:21,940
Did you remember all of the things that we've learned before

401
00:04:21,940 --> 00:04:26,940
like the in and the with open and also the converting to int?

402
00:04:27,790 --> 00:04:31,810
Did you manage to complete this challenge? If you had any trouble at all,

403
00:04:31,960 --> 00:04:34,840
be sure to review the relevant parts, for example,

404
00:04:35,080 --> 00:04:40,060
opening files or reading lines from the files which we covered in previous days.

405
00:04:40,690 --> 00:04:43,540
Alternatively, if it's the list comprehension that's hard,

406
00:04:43,930 --> 00:04:45,400
then be sure to review the list

407
00:04:45,400 --> 00:04:50,020
comprehension lesson in today's course and make sure that you really understand

408
00:04:50,020 --> 00:04:52,600
what's going on in the code before you continue.


409
00:00:00,900 --> 00:00:05,580
Now the reason why we're learning about list comprehensions is because when we

410
00:00:05,580 --> 00:00:07,980
created all US states game,

411
00:00:08,490 --> 00:00:13,490
I realized that the code that we were writing could be a lot shorter if only we

412
00:00:14,340 --> 00:00:15,840
knew about list comprehensions.

413
00:00:16,260 --> 00:00:21,260
So I want you to head back over to your code for the US states game and open it

414
00:00:21,930 --> 00:00:25,230
up. And I want you to look at this if statement.

415
00:00:25,770 --> 00:00:28,560
So when the user types exit,

416
00:00:29,070 --> 00:00:34,070
we create a new list of missing states in order to save it to a CSV file.

417
00:00:36,570 --> 00:00:38,190
I want you to change this code

418
00:00:38,220 --> 00:00:42,690
using your new knowledge of this comprehension and see if you can cut down this

419
00:00:42,690 --> 00:00:44,820
code by three or four lines.

420
00:00:45,660 --> 00:00:48,300
Pause the video and complete this challenge now.

421
00:00:51,510 --> 00:00:55,860
All right. So instead of all of this, creating a new empty missing state

422
00:00:55,860 --> 00:01:00,570
and then going through a for loop, we can simply do this in one line. So again,

423
00:01:00,570 --> 00:01:05,570
it's going to be called missing_states and this is going to be a new list,

424
00:01:06,330 --> 00:01:10,320
but this time it's going to be created using our list comprehension;

425
00:01:10,830 --> 00:01:13,950
new item for item in list

426
00:01:14,790 --> 00:01:15,900
if test.

427
00:01:16,620 --> 00:01:20,850
The list in this case that we're looping through is all of our states.

428
00:01:21,210 --> 00:01:23,910
So we're gonna replace that with all states. Now,

429
00:01:23,970 --> 00:01:27,390
each of the items is basically a state in that list.

430
00:01:28,020 --> 00:01:33,020
And the test that we're going to make is to see well if the state is not in the

431
00:01:35,250 --> 00:01:39,270
guessed_states which has states added every time

432
00:01:39,270 --> 00:01:41,010
the user makes a correct guess

433
00:01:41,400 --> 00:01:45,330
so we can basically take this part of our previous code and put it here.

434
00:01:45,870 --> 00:01:49,470
And in that case, then we're going to add this particular state

435
00:01:49,530 --> 00:01:53,760
which pass this test into this new list.

436
00:01:54,270 --> 00:01:55,380
This one line

437
00:01:55,440 --> 00:02:00,440
basically will replace all four of these lines and it cuts down dramatically

438
00:02:01,320 --> 00:02:02,340
on the amount of code.

439
00:02:02,820 --> 00:02:07,620
And it reads relatively well as well. Add a state to this new list

440
00:02:08,009 --> 00:02:11,130
if we loop through all the states in the list of states

441
00:02:11,430 --> 00:02:14,520
and if that state is not in this list of guessed

442
00:02:14,520 --> 00:02:16,860
states. List

443
00:02:16,860 --> 00:02:21,860
comprehensions are super popular with Python developers and I hope through some

444
00:02:22,500 --> 00:02:23,580
of these exercises

445
00:02:23,580 --> 00:02:28,580
you can see why, just in terms of the sheer amount of code that it cuts down on

446
00:02:28,980 --> 00:02:32,520
and how much it simplifies things. Now,

447
00:02:32,580 --> 00:02:34,500
in addition to list comprehensions,

448
00:02:34,800 --> 00:02:39,660
we can also do comprehensions with dictionaries. So in the next lesson,

449
00:02:39,780 --> 00:02:40,980
that's what we're going to be looking at.


450
00:00:00,450 --> 00:00:03,270
Now that you've seen how list comprehension works,

451
00:00:03,570 --> 00:00:07,290
it's time to learn about another type of comprehension, dictionary

452
00:00:07,290 --> 00:00:08,250
comprehensions.

453
00:00:08,820 --> 00:00:13,820
This is also super useful because it allows us to create a new dictionary from

454
00:00:14,940 --> 00:00:18,990
the values in a list or in a dictionary. For example,

455
00:00:19,050 --> 00:00:21,120
we could write out our keywords like this.

456
00:00:21,540 --> 00:00:24,180
We're going to create a new dictionary called new_dict,

457
00:00:24,600 --> 00:00:29,250
and it's going to be created using this curly bracket now instead of square

458
00:00:29,250 --> 00:00:33,420
brackets. And inside the comprehension, we get to set the new_key,

459
00:00:33,750 --> 00:00:38,190
the new_value, and we get to loop through items in a list.

460
00:00:38,430 --> 00:00:42,480
So any sort of iterable; a list, a range, a string, anything you want.

461
00:00:42,810 --> 00:00:45,810
And this is the simplest form of dictionary comprehension.

462
00:00:46,380 --> 00:00:51,380
Now remember that a dictionary comprehension is just a way of creating a

463
00:00:51,690 --> 00:00:54,540
dictionary using this shortened syntax.

464
00:00:55,020 --> 00:00:57,150
We could take this one step further.

465
00:00:57,570 --> 00:01:02,570
We could also create a new dictionary based on the values in an existing

466
00:01:03,600 --> 00:01:04,433
dictionary.

467
00:01:04,709 --> 00:01:09,710
So we could take that dictionary and then get hold of all of the items inside

468
00:01:10,080 --> 00:01:14,760
that dictionary, and then split it into a key and a value.

469
00:01:15,210 --> 00:01:19,680
So now, we're looping through each of the keys and each of the values in all of

470
00:01:19,680 --> 00:01:21,300
the items from the dictionary,

471
00:01:21,840 --> 00:01:26,840
and we can use these key and value variables to create a new_key or a new_value.

472
00:01:29,280 --> 00:01:33,300
And to go one step further for completion sake, we can, of course,

473
00:01:33,480 --> 00:01:36,570
as always add our condition at the very end,

474
00:01:36,690 --> 00:01:39,450
just like we did before with list comprehensions.

475
00:01:40,050 --> 00:01:42,450
So let's see how this code works in practice.

476
00:01:42,780 --> 00:01:44,790
I'm going to take my previous list of names

477
00:01:44,940 --> 00:01:49,920
and then I'm going to click on this button to refresh my console so that all of

478
00:01:49,920 --> 00:01:51,720
the previous variables get deleted.

479
00:01:52,410 --> 00:01:56,400
So now I'm going to create a new list of names.

480
00:01:57,120 --> 00:02:00,660
So I'm going to use the previous names I had before, and this is our list here.

481
00:02:01,260 --> 00:02:05,400
Now, the next thing I'm going to do is I'm going to create a dictionary where I

482
00:02:05,400 --> 00:02:09,509
generate a random score for each of these names.

483
00:02:09,780 --> 00:02:14,780
So let's imagine we had a bunch of students and we wanted to create some random

484
00:02:15,060 --> 00:02:19,170
scores for each of them so that they would get a random score between 1 and

485
00:02:19,170 --> 00:02:22,740
100. Now for the teachers out there,

486
00:02:22,740 --> 00:02:26,310
I really hope this is not what you do when you generate the students' scores.

487
00:02:26,850 --> 00:02:30,450
But essentially we want to create a dictionary

488
00:02:30,450 --> 00:02:35,430
which looks something like this. Each of the students in this list,

489
00:02:35,550 --> 00:02:40,140
so let's start out with Alex. We want our dictionary to have a key,

490
00:02:40,170 --> 00:02:43,080
which is the name of the student, and then a value,

491
00:02:43,110 --> 00:02:45,240
which is their random score.

492
00:02:45,750 --> 00:02:50,640
And we want to continue through that list of names until we've generated a

493
00:02:50,640 --> 00:02:53,970
random score for each of them. That's the goal.

494
00:02:54,090 --> 00:02:57,300
And now we have to use our dictionary comprehension.

495
00:02:57,930 --> 00:03:01,540
Remember, when we're creating a new list using lists comprehension,

496
00:03:01,570 --> 00:03:04,390
we're using square brackets. But now we're creating a dictionary

497
00:03:04,390 --> 00:03:08,080
so we're going to use curly brackets. Now, inside these curly brackets,

498
00:03:08,110 --> 00:03:10,750
I'm going to put down my usual list of keywords.

499
00:03:10,840 --> 00:03:13,900
So it's going to be a new_key:

500
00:03:13,960 --> 00:03:17,620
new_value that we're going to be adding to our new dictionary.

501
00:03:18,160 --> 00:03:19,480
And then I'm going to do

502
00:03:19,480 --> 00:03:23,770
a for item in list. In this case,

503
00:03:23,800 --> 00:03:28,090
our list or our iterable is going to be all lists of names.

504
00:03:28,810 --> 00:03:31,630
Now, even though in my keywords I always use lists,

505
00:03:31,870 --> 00:03:34,450
it's just easier to imagine. But it's actually, in fact,

506
00:03:34,450 --> 00:03:38,320
any sort of iterable like a range or a string or a tuple.

507
00:03:38,890 --> 00:03:40,990
Once we've got our list of names,

508
00:03:41,020 --> 00:03:43,450
we're going to name each of those names something,

509
00:03:43,510 --> 00:03:45,220
and I'm just going to call it student.

510
00:03:45,700 --> 00:03:49,900
So we're looping through all the students in our list of names here.

511
00:03:50,470 --> 00:03:52,300
And for each of those students,

512
00:03:52,330 --> 00:03:56,050
I'm going to create the student as the new key,

513
00:03:56,650 --> 00:04:00,610
but the value is going to be a new, random number.

514
00:04:01,030 --> 00:04:02,830
So in order to create a random number,

515
00:04:02,830 --> 00:04:06,370
I'm going to have to first import the random module.

516
00:04:06,760 --> 00:04:10,150
So I've cut out my previous code, imported random,

517
00:04:10,270 --> 00:04:11,860
and let's paste that code back in.

518
00:04:12,340 --> 00:04:17,339
So now we can replace the value for each of these dictionary entries with random

519
00:04:18,070 --> 00:04:19,269
.randint,

520
00:04:19,390 --> 00:04:23,530
and we can generate a random number between 1 and 100.

521
00:04:24,040 --> 00:04:28,240
So now when I hit enter, you'll see our new students_scores

522
00:04:28,240 --> 00:04:29,620
dictionary being created

523
00:04:29,950 --> 00:04:34,360
and you can see we've got all of our students in our list of names, Alex, Beth,

524
00:04:34,360 --> 00:04:35,710
Caroline, et cetera.

525
00:04:35,980 --> 00:04:40,060
And each of them now have a new random score.

526
00:04:40,810 --> 00:04:44,710
So it seems like everybody did pretty well other than Eleanor,

527
00:04:44,860 --> 00:04:49,450
I guess. Random score generating seems to work. Now,

528
00:04:49,480 --> 00:04:50,320
the next step,

529
00:04:50,350 --> 00:04:53,260
we're going to take this a little bit further because this was quite simple.

530
00:04:53,260 --> 00:04:57,190
We just did what we did before, which is looping through a list.

531
00:04:57,550 --> 00:05:01,810
But now I want to loop through a dictionary. Luckily,

532
00:05:01,810 --> 00:05:06,580
we've now created this brand, sparkling, new dictionary, our students_scores,

533
00:05:07,030 --> 00:05:11,050
and I want to use that dictionary in my next dictionary comprehension.

534
00:05:11,620 --> 00:05:15,640
So the next thing I want to do is to be able to create a dictionary called

535
00:05:15,700 --> 00:05:19,750
passed_students. And this is going to be a dictionary

536
00:05:19,780 --> 00:05:22,900
which looks through the dictionary of student_scores,

537
00:05:22,900 --> 00:05:26,320
so imagine you have an entire high school where everybody's scores are logged

538
00:05:26,710 --> 00:05:30,820
and you look at everybody who's got a score of 60 or over.

539
00:05:31,210 --> 00:05:32,080
And then we're going to say, well,

540
00:05:32,080 --> 00:05:35,920
those people have passed and everybody else has failed that year.

541
00:05:36,640 --> 00:05:41,350
Essentially we should loop through this entire dictionary of items,

542
00:05:41,620 --> 00:05:46,030
figure out which of these have a value that's equal to 60 or over 60,

543
00:05:46,540 --> 00:05:51,070
and then we're gonna add those items back into this new dictionary

544
00:05:51,130 --> 00:05:52,450
of passed_students.

545
00:05:53,620 --> 00:05:58,550
So essentially, we'd probably end up with, um, Beth,

546
00:05:58,580 --> 00:06:02,000
with Caroline, with Dave and with Freddy.

547
00:06:02,510 --> 00:06:07,510
So it will still look pretty much the same as our students_scores dictionary.

548
00:06:08,120 --> 00:06:11,870
So it would have something like Beth and then colon her score,

549
00:06:11,900 --> 00:06:16,550
which is 72. But just the fact that she's included in this dictionary,

550
00:06:16,580 --> 00:06:17,900
it means that she has passed.

551
00:06:18,650 --> 00:06:23,650
And we will end up with this new dictionary where everybody is a passed student

552
00:06:24,260 --> 00:06:25,580
and bear scores.

553
00:06:27,140 --> 00:06:31,700
Have a think about how you might do this. And if you're up for the challenge,

554
00:06:31,760 --> 00:06:35,120
try pausing the video and seeing if you can complete this.

555
00:06:37,250 --> 00:06:41,900
As always, we know that we're going to create a new dictionary, so curly braces,

556
00:06:42,260 --> 00:06:46,100
and then it's going to be our new_key: new_value.

557
00:06:46,670 --> 00:06:50,180
And then it's going to be for, and now,

558
00:06:50,210 --> 00:06:55,210
because we are looping through this dictionary and we want to get hold of each

559
00:06:55,490 --> 00:06:56,323
of the values,

560
00:06:56,660 --> 00:07:00,980
we're going to use the method that we saw in our previous slides.

561
00:07:01,160 --> 00:07:06,160
So we're going to get hold of each of the keys and the value from our

562
00:07:07,040 --> 00:07:09,890
dictionary. And then after the in keyword,

563
00:07:09,920 --> 00:07:13,760
it's the thing that we actually want to loop through, which is our dictionary.

564
00:07:15,260 --> 00:07:16,700
Once we've got our dictionary,

565
00:07:16,700 --> 00:07:20,210
then we need to call the items method on that dictionary.

566
00:07:20,210 --> 00:07:23,000
So it's items with a set of parentheses,

567
00:07:23,060 --> 00:07:25,490
not just the items as an attribute.

568
00:07:26,150 --> 00:07:28,340
So now that we've got our keywords down,

569
00:07:28,340 --> 00:07:30,950
let's convert it to our particular case.

570
00:07:31,370 --> 00:07:35,210
So our dictionary is called students_scores,

571
00:07:35,420 --> 00:07:37,070
let's make sure I spell it correctly.

572
00:07:37,400 --> 00:07:42,140
So students_scores.items gets all of the items in that dictionary.

573
00:07:42,650 --> 00:07:44,360
And then for each of the keys

574
00:07:44,420 --> 00:07:47,750
which is going to be students, and for each of the values

575
00:07:47,750 --> 00:07:52,610
which is going to be their score, we're going to loop through this dictionary.

576
00:07:53,180 --> 00:07:58,130
The new key is just going to be the student's name and the new value is just

577
00:07:58,130 --> 00:07:59,510
going to be their score.

578
00:08:00,050 --> 00:08:05,050
But what we need to do is we need to check using an if statement,

579
00:08:05,750 --> 00:08:09,530
if the student that we're currently looping through has passed.

580
00:08:09,980 --> 00:08:14,980
So the test is basically looking at the score and seeing if it is greater than

581
00:08:15,920 --> 00:08:19,820
or equal to 60. And if that is the case,

582
00:08:19,850 --> 00:08:22,910
then we're going to take this student as the new key,

583
00:08:23,150 --> 00:08:27,860
their score as the new value, and place it inside this new dictionary.

584
00:08:28,550 --> 00:08:31,280
So now if I go ahead and hit enter,

585
00:08:31,640 --> 00:08:35,480
then you can see we've got our new dictionary being created,

586
00:08:35,900 --> 00:08:40,130
which only contains all the students who have passed. So it's Beth, Caroline,

587
00:08:40,159 --> 00:08:43,700
Dave, and Freddy, and we've lost Alex and Eleanor.

588
00:08:45,500 --> 00:08:47,480
So in order to get more practice at this,

589
00:08:47,570 --> 00:08:52,250
I've prepared some more coding exercises for you on dictionary comprehension.

590
00:08:52,550 --> 00:08:55,250
So head over to the next lesson and we'll get started.


591
00:00:00,300 --> 00:00:00,630
All right.

592
00:00:00,630 --> 00:00:04,620
It's time to put what you've learned to practice and see if you can complete

593
00:00:04,620 --> 00:00:07,110
these challenges on dictionary comprehension.

594
00:00:07,710 --> 00:00:12,690
So I want you to find the exercise that is day 26.4.

595
00:00:13,350 --> 00:00:17,190
Now, once you've found day 26.4 dictionary comprehension one,

596
00:00:17,460 --> 00:00:21,030
you'll see that this is the starting code I have for you.

597
00:00:21,030 --> 00:00:22,530
I've got a sentence here

598
00:00:22,710 --> 00:00:26,640
which is a string and your job is to count

599
00:00:26,730 --> 00:00:31,350
how many letters there are in each word and create a dictionary that looks like

600
00:00:31,350 --> 00:00:32,183
this.

601
00:00:32,220 --> 00:00:36,060
So your final dictionary is going to be saved as this variable called

602
00:00:36,060 --> 00:00:38,700
result and it's going to be printed to the console.

603
00:00:39,420 --> 00:00:41,130
Have a read of the instructions,

604
00:00:41,490 --> 00:00:45,270
especially be aware that you might need to do some Googling to figure out how to

605
00:00:45,270 --> 00:00:49,620
convert a sentence into a list of words and use the hints if you need them.

606
00:00:50,070 --> 00:00:52,230
So pause the video and give that a go now.

607
00:00:53,300 --> 00:00:54,133
Okay.

608
00:00:57,170 --> 00:01:01,010
The biggest hurdle of this challenge is not actually the dictionary 

609
00:01:01,010 --> 00:01:01,843
comprehension.

610
00:01:02,210 --> 00:01:07,210
It's the figuring of out how to convert a sentence, a string, into a list of words.

611
00:01:08,360 --> 00:01:13,190
So I've basically just typed out the entire query with Python at the end into

612
00:01:13,190 --> 00:01:17,060
Google. And if I click on the first Stack Overflow answer,

613
00:01:17,330 --> 00:01:22,250
you can see that they're telling you that you should probably investigate the split

614
00:01:22,310 --> 00:01:23,143
method.

615
00:01:23,450 --> 00:01:28,450
The split method basically splits a string by space and converts it into a list.

616
00:01:28,910 --> 00:01:32,450
That's exactly what we need in order to solve this challenge.

617
00:01:32,930 --> 00:01:37,930
And also in the hints, you can see that I've linked it to a page in the W3

618
00:01:38,240 --> 00:01:40,400
Schools documentation for Python.

619
00:01:40,850 --> 00:01:43,970
And I like looking to the W3Schools just because you have the

620
00:01:43,970 --> 00:01:45,080
try-it-yourself section

621
00:01:45,080 --> 00:01:50,080
where you can actually run the code and see what is the result of running this

622
00:01:50,570 --> 00:01:53,600
method. So if you have a sentence, Welcome to the jungle,

623
00:01:53,630 --> 00:01:55,250
once you call split on it,

624
00:01:55,490 --> 00:01:59,780
it creates a list with each word as a separate item in the list.

625
00:02:00,530 --> 00:02:03,680
Now we're basically ready to tackle our challenge.

626
00:02:04,520 --> 00:02:09,139
We're going to create our result which is going to be a dictionary.

627
00:02:09,620 --> 00:02:14,420
So let's start out with the keyword methods. So we'll say new_key:

628
00:02:14,450 --> 00:02:19,450
new_value for item in list.

629
00:02:20,570 --> 00:02:21,470
Now, in this case,

630
00:02:21,500 --> 00:02:26,500
we're not actually iterating through a dictionary and we're only iterating

631
00:02:27,140 --> 00:02:29,780
through a string, which is just a sequence.

632
00:02:30,200 --> 00:02:35,150
So we can replace this list with our sentence, but we can't leave it at

633
00:02:35,180 --> 00:02:40,010
just the sentence, because then it's going to loop through each of the letters.

634
00:02:40,520 --> 00:02:44,120
So instead of having it as just the sentence string,

635
00:02:44,210 --> 00:02:49,210
we're going to use the split method to convert it into a list of words.

636
00:02:50,390 --> 00:02:53,540
And once we've done that, then every time we loop through it,

637
00:02:53,600 --> 00:02:58,040
we're actually looping through each word in this list.

638
00:02:58,930 --> 00:03:01,840
And it's usually a good idea to test out the code.

639
00:03:01,870 --> 00:03:05,020
So let's comment out these last two lines of code,

640
00:03:05,380 --> 00:03:10,380
and then let's take our sentence and let's say for word in sentence.split.

641
00:03:13,060 --> 00:03:17,560
And now let's print out each of the words. And when I run this,

642
00:03:17,590 --> 00:03:22,590
you can see it has split our entire sentence by the spaces to create a list of

643
00:03:23,590 --> 00:03:27,760
words. And each time it iterates through it using for word in sentence.split

644
00:03:27,790 --> 00:03:28,960
just like we have here,

645
00:03:29,260 --> 00:03:34,000
it's going to go through each word in turn and then check each of them.

646
00:03:34,720 --> 00:03:39,720
So now let's reactivate our code. And we wanna fix the very last part.

647
00:03:40,960 --> 00:03:44,590
So the new key is going to be the actual word

648
00:03:44,650 --> 00:03:49,650
because we want each of the words in our dictionary as the key, and the new value

649
00:03:49,690 --> 00:03:54,040
is going to be the length of the word. So now when I hit run,

650
00:03:54,100 --> 00:03:59,100
you can see we've got a dictionary where each word is the key and the number of

651
00:03:59,320 --> 00:04:02,200
characters in each word is the value.

652
00:04:02,920 --> 00:04:04,810
And now I've completed the challenge.


653
00:00:00,600 --> 00:00:04,830
All right. So now we're on to the next dictionary comprehension exercise,

654
00:00:04,860 --> 00:00:08,370
which is day 26.5 dictionary comprehension two.

655
00:00:09,060 --> 00:00:09,960
And in this challenge,

656
00:00:09,990 --> 00:00:14,990
you are going to be converting a dictionary of temperatures in Celsius to their

657
00:00:16,020 --> 00:00:18,870
corresponding temperature in Fahrenheit.

658
00:00:19,320 --> 00:00:23,430
So this is how you convert a Celsius temperature to Fahrenheit.

659
00:00:23,730 --> 00:00:28,730
So the temperature multiplied by nine divided by five and then plus 32.

660
00:00:29,400 --> 00:00:33,330
So you saw this in a previous lesson as well. So pause the video,

661
00:00:33,390 --> 00:00:36,090
have a read of the instructions, take a look at the hints

662
00:00:36,090 --> 00:00:38,940
if you get stuck and see if you can complete this challenge.

663
00:00:42,200 --> 00:00:43,130
So in this case, 

664
00:00:43,190 --> 00:00:48,190
we have a slightly different exercise from before because we're now going to be

665
00:00:48,590 --> 00:00:51,710
working with a dictionary to create a new dictionary.

666
00:00:52,280 --> 00:00:56,660
Let's write our code here and let's create our new variable

667
00:00:56,660 --> 00:01:00,170
which needs to be called weather_f. And this

668
00:01:00,170 --> 00:01:02,390
weather_f is going to be a new dictionary.

669
00:01:03,110 --> 00:01:06,050
Let's put in our keyword method to

670
00:01:06,080 --> 00:01:08,480
create a new dictionary from a dictionary.

671
00:01:08,630 --> 00:01:13,630
So new_key:new_value for,

672
00:01:14,360 --> 00:01:16,550
and then it's parentheses key,

673
00:01:16,880 --> 00:01:20,150
value. So, be really careful here.

674
00:01:20,210 --> 00:01:24,470
I've seen a lot of students just use the colon in this case,

675
00:01:24,470 --> 00:01:28,160
but it's actually a tuple. So it should be key, value.

676
00:01:28,580 --> 00:01:32,630
And then we specify the dictionary that we want to loop through.

677
00:01:33,620 --> 00:01:38,090
And then we call .items on it. And remember, this is a method,

678
00:01:38,090 --> 00:01:39,980
so it needs the parentheses at the end.

679
00:01:40,640 --> 00:01:44,450
So now let's replace the relevant parts of this line.

680
00:01:44,780 --> 00:01:46,970
So our dictionary is going to be this one,

681
00:01:47,030 --> 00:01:51,920
our weather_c. That's the dictionary we're looping through.

682
00:01:52,010 --> 00:01:55,160
And we're gonna get a hold of all of the items in that dictionary

683
00:01:55,550 --> 00:02:00,170
and then get each of the keys which I'll call day, and value

684
00:02:00,170 --> 00:02:04,820
which I'll call temp_c because it will be the temperature in Celsius.

685
00:02:05,420 --> 00:02:10,419
So now that I'm looping through each of the days and the temperatures in our

686
00:02:11,300 --> 00:02:15,320
weather dictionary, then we're going to create our new key and new value.

687
00:02:15,770 --> 00:02:18,920
So the new key is actually still going to be the same day.

688
00:02:18,950 --> 00:02:23,060
It's going to be unchanged because we want this as our output

689
00:02:23,180 --> 00:02:25,100
and it looks pretty much the same as this one,

690
00:02:25,460 --> 00:02:27,920
other than the fact that we've converted the value.

691
00:02:28,490 --> 00:02:32,540
So the new value though is going to be calculated using this formula.

692
00:02:32,720 --> 00:02:37,720
So we're going to take our temp_c and then we're going to multiply it by nine

693
00:02:38,300 --> 00:02:43,270
divided by five. And then we're going to add 32. If you want,

694
00:02:43,310 --> 00:02:46,970
you can add the parentheses around this line,

695
00:02:47,300 --> 00:02:50,480
but because we're doing math and we're going from left to right,

696
00:02:50,570 --> 00:02:55,280
and we're first doing multiply divide, then we do add and subtract,

697
00:02:55,310 --> 00:02:57,860
then it's actually completely optional in this case.

698
00:02:58,070 --> 00:03:02,320
But we'll just include it in there for completion sake. So now when I hit run,

699
00:03:03,190 --> 00:03:03,870
you'll see that

700
00:03:03,870 --> 00:03:08,430
I've got a dictionary that's being generated with each of the days in the week

701
00:03:08,490 --> 00:03:09,870
from this dictionary

702
00:03:10,230 --> 00:03:13,560
and each of the temperatures have been converted to Fahrenheit.

703
00:03:13,890 --> 00:03:15,360
So this is super useful

704
00:03:15,360 --> 00:03:19,290
and you often find yourself needing to work with values in a dictionary.


705
00:00:00,960 --> 00:00:01,740
In this lesson,

706
00:00:01,740 --> 00:00:06,120
I want to show you how you can use loops with pandas dataframes and how to

707
00:00:06,120 --> 00:00:11,010
iterate over a pandas data frame. So here, I've got a simple dictionary,

708
00:00:11,280 --> 00:00:15,720
I've got two keys, student and score, and under student

709
00:00:15,750 --> 00:00:18,870
I've got a list of student names, and under score

710
00:00:18,870 --> 00:00:21,480
I've got a list of their corresponding scores.

711
00:00:21,990 --> 00:00:26,990
Now we know that we can loop through a dictionary very simply by creating a for

712
00:00:28,500 --> 00:00:30,540
loop and then we say, well,

713
00:00:30,600 --> 00:00:35,600
we're going to go through each of the key and values inside this student

714
00:00:36,120 --> 00:00:36,953
dictionary.

715
00:00:37,230 --> 00:00:41,190
And then we're going to get all of the items in order to be able to loop through

716
00:00:41,190 --> 00:00:45,360
it. So now when I print each of the keys,

717
00:00:45,690 --> 00:00:49,770
you can see that it goes through the dictionary and prints both of the keys.

718
00:00:50,910 --> 00:00:54,240
And similarly, I can get it to loop through both of the values.

719
00:00:54,660 --> 00:00:57,540
So this is how we've been looping through dictionaries

720
00:00:57,870 --> 00:01:01,020
and we've been using it in our dictionary comprehension.

721
00:01:01,890 --> 00:01:05,820
Now you can loop through a data frame in the same way that you loop through a

722
00:01:05,820 --> 00:01:07,800
dictionary. In a lot of ways,

723
00:01:07,830 --> 00:01:12,360
you can consider a data frame pretty much as if you're working with a Python

724
00:01:12,360 --> 00:01:16,170
dictionary. So I'm going to go ahead and import pandas

725
00:01:16,710 --> 00:01:20,730
and I'm going to use pandas to create a new data frame,

726
00:01:21,390 --> 00:01:24,840
and it's going to be created from our student dictionary.

727
00:01:25,230 --> 00:01:26,760
So you've seen all of this before,

728
00:01:26,820 --> 00:01:31,820
and I'll just call this the student_data_frame and I can print it for you to see

729
00:01:34,080 --> 00:01:34,910
what it looks like.

730
00:01:34,910 --> 00:01:35,743
Okay.

731
00:01:38,630 --> 00:01:40,280
This is our data frame.

732
00:01:40,280 --> 00:01:45,280
It looks like a pretty standard table with the first column being all of the

733
00:01:45,290 --> 00:01:49,280
indices. So at zero index is this first row,

734
00:01:49,940 --> 00:01:53,480
and that basically denotes the index of each row.

735
00:01:54,230 --> 00:01:56,660
Now working with this data frame,

736
00:01:56,750 --> 00:02:01,750
we can actually loop through a data frame using the same method as before.

737
00:02:02,990 --> 00:02:07,990
So we can say for key, value in our student_data_frame .items.

738
00:02:14,390 --> 00:02:17,690
So if I print each of the keys,

739
00:02:18,980 --> 00:02:23,180
you can see it's just going to give me the titles of each column.

740
00:02:23,810 --> 00:02:26,720
But if I print each of the values,

741
00:02:28,520 --> 00:02:32,030
then it's going to give me the data in each of the columns.

742
00:02:32,660 --> 00:02:37,280
Now this is not particularly useful because it's basically just looping through

743
00:02:37,610 --> 00:02:42,110
the names of our columns and then the data inside each column.

744
00:02:42,710 --> 00:02:46,430
This is why pandas has a inbuilt  loop

745
00:02:47,180 --> 00:02:50,690
and it's a method called iterrows.

746
00:02:51,140 --> 00:02:56,140
And it allows us to loop through each of the rows of the data frame rather than

747
00:02:56,540 --> 00:02:57,680
each of the columns.

748
00:02:58,490 --> 00:03:03,490
And the way that we do that is we again use a for loop and then we can get hold

749
00:03:03,910 --> 00:03:07,030
of each of the index inside each row,

750
00:03:07,030 --> 00:03:10,570
so that corresponds to the number in that first column.

751
00:03:11,050 --> 00:03:14,320
And then we can get hold of the data in the row.

752
00:03:15,010 --> 00:03:19,660
And then we can say for index row in data frame,

753
00:03:19,690 --> 00:03:23,530
which is student_data_frame, and then its that method.iter

754
00:03:23,530 --> 00:03:24,850
rows.

755
00:03:26,290 --> 00:03:31,290
And now I can loop through each of those rows and print out either the index for

756
00:03:34,150 --> 00:03:35,260
each of those rows.

757
00:03:36,250 --> 00:03:39,820
So you can see that this is going to print out our data frame here,

758
00:03:40,150 --> 00:03:43,360
And then in order to print out each of the index at 0, 1, 2.

759
00:03:43,750 --> 00:03:46,900
But I can also print out each of the rows.

760
00:03:47,530 --> 00:03:52,530
So now I get the first row has a student and a score,

761
00:03:53,380 --> 00:03:57,310
the second row has a student and a score, and the third row has a student and

762
00:03:57,310 --> 00:03:58,143
score.

763
00:03:58,540 --> 00:04:03,540
So each of these rows is a pandas series object. So that means we can tap into the

764
00:04:04,480 --> 00:04:09,480
row and then get hold of the value under a particular column by using the dot

765
00:04:10,690 --> 00:04:13,930
notation. So we can say row.student

766
00:04:14,470 --> 00:04:16,360
and now when it goes through the loop,

767
00:04:16,690 --> 00:04:19,540
you can see first, it's going to print out our entire data frame,

768
00:04:19,870 --> 00:04:24,490
and then it's going to print out each of the students inside that data frame.

769
00:04:25,090 --> 00:04:28,240
Now I can also say row.score,

770
00:04:28,900 --> 00:04:32,320
and now it's going to give me each of the scores inside the data frame.

771
00:04:32,740 --> 00:04:35,320
And I can even do something like this where I say

772
00:04:35,410 --> 00:04:40,410
if the row.student is equal to Angela,

773
00:04:41,440 --> 00:04:46,440
well then we can print that particular row that we're currently looping on, 

774
00:04:47,020 --> 00:04:51,850
.score. And this way we would get the student, Angela's score

775
00:04:51,880 --> 00:04:56,050
which happens to be 56, as you can verify here.


776
00:00:00,270 --> 00:00:03,360
Now we're finally ready to tackle our project,

777
00:00:03,510 --> 00:00:08,510
and this project is based on a real-life struggle that I have. Often when I'm

778
00:00:09,480 --> 00:00:13,830
calling a company and over the phone I have to give some sort of details

779
00:00:13,830 --> 00:00:16,680
right? They'll ask me, what is your name, and can you spell it?

780
00:00:16,890 --> 00:00:21,360
So I'll have to be like A-N-G-E-L-A. And they're like, wait, was that an E?

781
00:00:21,390 --> 00:00:24,390
Was that a B, what did you say? In these cases

782
00:00:24,390 --> 00:00:29,070
often I have to sort of default to some sort of Naval alphabet. where

783
00:00:29,070 --> 00:00:32,220
I say A is the alfa, N for November, G for golf.

784
00:00:32,610 --> 00:00:36,870
And then at some point I forget what E stands for and I'm like E for.. elephant?

785
00:00:37,530 --> 00:00:42,180
And there have been times where I've just completely taken the MIG and said

786
00:00:42,180 --> 00:00:46,170
things like M for mnemonic, P for pneumonia, W for wrench,

787
00:00:46,440 --> 00:00:47,880
which doesn't make any sense at all

788
00:00:47,880 --> 00:00:52,880
because these are silent letters. And I've had some very angry people,

789
00:00:52,950 --> 00:00:54,570
um, but it was quite fun.

790
00:00:55,110 --> 00:00:59,610
So now what we want to create is we want to create a tool that takes the NATO

791
00:00:59,610 --> 00:01:03,840
phonetic alphabet which was generated because it's often really,

792
00:01:03,840 --> 00:01:08,840
really important for the other side to know exactly what it is that you said and

793
00:01:08,970 --> 00:01:13,970
which letters you're spelling out so that they don't mistaken your E for a B or

794
00:01:15,000 --> 00:01:16,500
your T for a C

795
00:01:16,530 --> 00:01:20,700
cause it all sounds really similar. Head over to the course resources page

796
00:01:20,760 --> 00:01:24,120
where you can find the starting files for the NATO alphabet project.

797
00:01:24,990 --> 00:01:29,730
I want you to practice with list comprehension and with dictionary

798
00:01:29,730 --> 00:01:31,980
comprehension. But in this case,

799
00:01:32,010 --> 00:01:34,800
we're not going through a dictionary per se,

800
00:01:34,830 --> 00:01:39,830
but we're actually going through a data frame because our data lives inside a

801
00:01:39,930 --> 00:01:43,830
CSV. So we're going to be reading it using pandas.

802
00:01:44,130 --> 00:01:49,130
and then we're going to end up with a data frame. Instead of having a bog

803
00:01:49,410 --> 00:01:54,150
standard dictionary comprehension where our keywords were new_key:

804
00:01:54,180 --> 00:01:59,180
new_value for key, value in dict.items.

805
00:02:05,130 --> 00:02:08,430
Now we're going to change this for-loop

806
00:02:08,490 --> 00:02:11,330
so instead of using the simple for loop where

807
00:02:11,410 --> 00:02:12,990
we're just looping through a dictionary,

808
00:02:13,380 --> 00:02:17,670
we're going to use this particular loop. So then in this case,

809
00:02:17,700 --> 00:02:22,700
we're saying for index row in our data frame,

810
00:02:24,300 --> 00:02:28,740
and then it's .iterrows as the method.

811
00:02:29,220 --> 00:02:34,220
So basically I want you to use this different loop in order to loop through our

812
00:02:34,440 --> 00:02:39,440
data frame and then create a new dictionary using a new key and new value.

813
00:02:41,130 --> 00:02:45,390
So what exactly is it that I want you to do with this? Well,

814
00:02:45,420 --> 00:02:49,380
I want you to be able to take the CSV of NATO phonetic alphabet,

815
00:02:49,830 --> 00:02:51,690
and I want you to do two things to it.

816
00:02:52,140 --> 00:02:57,140
The first thing is for you to create a dictionary in this format.

817
00:03:01,000 --> 00:03:06,000
The format is basically the key is going to be the actual letter,

818
00:03:06,130 --> 00:03:11,130
so maybe A. And then the value is going to be the corresponding code for the NATO

819
00:03:12,460 --> 00:03:15,700
phonetic alphabet. So A actually is for alpha.

820
00:03:16,150 --> 00:03:20,530
And then the next one is B, which stands for Bravo.

821
00:03:21,490 --> 00:03:22,180
Essentially,

822
00:03:22,180 --> 00:03:26,830
we're going to take the CSV and we're going to convert it into a dictionary in

823
00:03:26,830 --> 00:03:30,190
this particular format where the keys

824
00:03:30,190 --> 00:03:34,330
are the letters inside the CSV, so that first column,

825
00:03:34,690 --> 00:03:39,690
and then the values are the corresponding code words for each of those letters.

826
00:03:40,630 --> 00:03:45,250
And the reason why we're talking about iterrows and had to loop through rows of a

827
00:03:45,250 --> 00:03:49,570
data frame instead of just getting you to get hold of the data frame

828
00:03:49,900 --> 00:03:52,270
and then just say to_dict

829
00:03:52,420 --> 00:03:56,590
like what we did before, is because it's not going to give it to you in this

830
00:03:56,590 --> 00:03:57,640
particular format.

831
00:03:58,000 --> 00:04:01,210
So you're going to have to use what you've learned about dictionary

832
00:04:01,210 --> 00:04:05,770
comprehension in order to create a dictionary in this particular format.

833
00:04:06,370 --> 00:04:08,830
And then once you've created a dictionary in this format,

834
00:04:08,860 --> 00:04:11,200
then the next step is a lot easier.

835
00:04:11,500 --> 00:04:16,500
You are going to create a list of the phonetic code words from a word that the

836
00:04:19,450 --> 00:04:20,620
user inputs.

837
00:04:21,940 --> 00:04:26,410
That way the user can use the input to type a word.

838
00:04:26,830 --> 00:04:30,430
So for example, Thomas, and then when they hit enter,

839
00:04:30,550 --> 00:04:32,740
they get a list printed out

840
00:04:33,010 --> 00:04:38,010
that is the phonetic alphabet code word for each of the letters in their input.

841
00:04:39,190 --> 00:04:41,800
So Tango, Hotel, Oscar Mike, Alpha Sierra,

842
00:04:41,830 --> 00:04:45,160
which they can then read back using our little tool.

843
00:04:46,210 --> 00:04:50,290
I would say that to do step 1 is a lot harder than to do step 2.

844
00:04:50,620 --> 00:04:54,070
But essentially, to do step 1 is a dictionary comprehension,

845
00:04:54,160 --> 00:04:58,630
creating a dictionary in this format from the CSV, and to do 

846
00:04:58,630 --> 00:05:03,630
number 2 is basically completing the project and being able to create and

847
00:05:03,910 --> 00:05:08,860
print out a list of the code words based on the word that the user inputs.

848
00:05:09,400 --> 00:05:13,570
So I want you to pause the video, have a think about how you might solve this,

849
00:05:13,900 --> 00:05:18,900
and then go ahead to the course resources and download this starting zip file so

850
00:05:20,170 --> 00:05:24,370
that you can open it up inside PyCharm and create your project.

851
00:05:24,880 --> 00:05:26,770
Pause the video and give that a go now.


852
00:00:00,240 --> 00:00:05,220
Once you've unzipped and opened up the starting file inside PyCharm,

853
00:00:05,610 --> 00:00:06,689
this is what you'd see.

854
00:00:06,780 --> 00:00:11,610
There is a CSV file that contains each of the letters and the code word,

855
00:00:11,970 --> 00:00:16,379
and there's also our main.py with some of the example code that I showed you

856
00:00:16,379 --> 00:00:18,480
in the last lesson. Now,

857
00:00:18,510 --> 00:00:23,400
if you don't know how to complete this challenge, especially step 1,

858
00:00:23,760 --> 00:00:28,760
I really urge you to go through this example code and just go through each of

859
00:00:29,730 --> 00:00:33,480
the different types of loops and see what it is that you get when you print the

860
00:00:33,480 --> 00:00:37,170
key or the value. And in this case, when you print the index

861
00:00:37,200 --> 00:00:41,550
or when you print the row. And then see what happens when you get hold of some of

862
00:00:41,550 --> 00:00:46,500
the items in the row. And seeing how maybe the row.student or the row.

863
00:00:46,500 --> 00:00:49,560
score works. Once you fully understood this,

864
00:00:49,590 --> 00:00:53,250
then it should be relatively easy to complete step 1.

865
00:00:53,880 --> 00:00:58,110
So essentially the goal is that we want to create a dictionary that looks like

866
00:00:58,110 --> 00:00:59,760
this from the CSV.

867
00:01:00,360 --> 00:01:04,379
The first thing we have to do is to go ahead and import pandas.

868
00:01:06,270 --> 00:01:09,540
And if you need to install it, there should be a squiggly line

869
00:01:09,570 --> 00:01:10,680
and then you can click on it

870
00:01:10,800 --> 00:01:14,550
and the light bulb will help you install the pandas module.

871
00:01:14,940 --> 00:01:17,400
But once we've gotten hold of the pandas,

872
00:01:17,430 --> 00:01:22,350
we can go ahead and use it to read CSV from our file

873
00:01:22,350 --> 00:01:27,270
which is this file. It's under the file path of just nato_phonetic_

874
00:01:27,270 --> 00:01:31,470
alphabet.csv. So it will save this as our data

875
00:01:31,500 --> 00:01:34,890
which is basically going to be our data frame. Now,

876
00:01:34,890 --> 00:01:37,440
once we've got hold of our data,

877
00:01:37,560 --> 00:01:41,010
then you can see that if we print this out,

878
00:01:41,880 --> 00:01:43,800
it looks like this.

879
00:01:44,250 --> 00:01:49,250
But if we use that method, to_dict, and then we try to print it out,

880
00:01:49,950 --> 00:01:54,060
you can see that it's not organized the dictionary in the format that we want it

881
00:01:54,060 --> 00:01:57,780
to, which is to have the letter as the key,

882
00:01:57,990 --> 00:02:02,730
the corresponding code as the value. In order to complete step 1

883
00:02:02,820 --> 00:02:06,300
as I mentioned, we're going to have to use dictionary comprehension.

884
00:02:06,750 --> 00:02:11,750
And the method is going to be using the iterrows to iterate through each of the

885
00:02:12,690 --> 00:02:17,340
rows inside that data frame. So I'm going to copy that line here,

886
00:02:17,580 --> 00:02:20,490
and I'm going to paste it in here.

887
00:02:21,150 --> 00:02:25,860
Now, this is the format, so let's go ahead and replace each of the keywords.

888
00:02:26,250 --> 00:02:29,250
Our data frame, in our case, is just called data.

889
00:02:30,000 --> 00:02:33,900
And then we're going to say data iterate through each of the rows,

890
00:02:34,170 --> 00:02:37,020
and then for each of the index and the row,

891
00:02:37,230 --> 00:02:39,270
we're going to do something with it.

892
00:02:39,900 --> 00:02:44,900
Now the new key is going to be the row.letter and the new value is going to

893
00:02:49,200 --> 00:02:54,180
come from that row as well and it's going to be row.code.

894
00:02:55,020 --> 00:02:58,650
So this is the code that will create our new dictionary

895
00:02:59,110 --> 00:03:03,670
and I'm going to call this our phonetic_dictionary.

896
00:03:04,840 --> 00:03:06,580
Now, if I print that out,

897
00:03:07,630 --> 00:03:12,370
you can see that this is the straight up data.to_dict

898
00:03:12,790 --> 00:03:16,810
and then the second line is the one where we've actually formatted it

899
00:03:17,140 --> 00:03:20,980
using what we've learned about dictionary comprehension.

900
00:03:21,730 --> 00:03:25,570
Once we've gotten hold of this phonetic dictionary,

901
00:03:25,630 --> 00:03:30,630
then to do step 2 is incredibly easy because all we have to do is to create

902
00:03:31,120 --> 00:03:35,200
some sort of inputs, ask the user to enter a word,

903
00:03:35,560 --> 00:03:39,220
and then we can save this input to a variable. Now,

904
00:03:39,250 --> 00:03:41,320
once they've entered the word,

905
00:03:41,530 --> 00:03:46,530
we have to check it against each of the keys inside this phonetic dictionary.

906
00:03:47,410 --> 00:03:50,470
So notice how each of the keys all uppercased.

907
00:03:50,800 --> 00:03:55,480
So we're going to have to change whatever it is that the user has inputted all

908
00:03:55,510 --> 00:04:00,220
to upper. So that way, if they entered a lowercase or an uppercase,

909
00:04:00,220 --> 00:04:03,750
it doesn't really matter because we're going to convert the whole string to

910
00:04:03,760 --> 00:04:08,020
uppercase. And then we're going to use our list comprehension.

911
00:04:08,890 --> 00:04:13,890
The way we create our list comprehension is going to be new item for item in

912
00:04:14,890 --> 00:04:16,570
list. So in this case,

913
00:04:16,570 --> 00:04:20,529
our list or the thing that we're going to iterate through is going to be our

914
00:04:20,529 --> 00:04:21,363
word.

915
00:04:21,640 --> 00:04:25,540
And then we're going to go through each of the letters in the word.

916
00:04:26,770 --> 00:04:29,170
And once we have each of the letters,

917
00:04:29,230 --> 00:04:33,640
we're going to go through our phonetic dictionary, this one right here,

918
00:04:33,730 --> 00:04:38,440
and pick out the value that corresponds to the particular letter that we're

919
00:04:38,440 --> 00:04:39,310
iterating on.

920
00:04:39,550 --> 00:04:42,970
So we're going to use the square brackets and then pass in the letter like this.

921
00:04:43,600 --> 00:04:48,600
Now we've created our output list and we can go ahead and print it out.

922
00:04:51,310 --> 00:04:56,310
Now let's go ahead and comment out this line and run our code.

923
00:04:58,120 --> 00:05:01,300
So it's going to ask me to enter a word, I'm going to enter my name.

924
00:05:01,660 --> 00:05:06,660
And now it's managed to convert that into a list of phonetic alphabets that

925
00:05:07,450 --> 00:05:10,300
corresponds to each of the letters in that word.

926
00:05:11,200 --> 00:05:15,010
Did you manage to complete this challenge? And if not,

927
00:05:15,220 --> 00:05:16,930
which part did you stumble on?

928
00:05:17,320 --> 00:05:21,370
Was it the part where you were using the iterrows? If so,

929
00:05:21,370 --> 00:05:25,720
then go back to the starting file for this project and go through each of the

930
00:05:25,720 --> 00:05:29,560
different ways that we're looping through it and use print statements to really

931
00:05:29,560 --> 00:05:34,360
understand how the loop is actually going through and looking through the data.

932
00:05:35,080 --> 00:05:35,470
Now,

933
00:05:35,470 --> 00:05:40,240
if on the other hand, it was the dictionary comprehension or the list

934
00:05:40,240 --> 00:05:41,073
comprehension,

935
00:05:41,320 --> 00:05:44,950
then be sure to go back to the relevant lesson and just make sure that you

936
00:05:44,950 --> 00:05:48,130
review it and you write out the code in the lesson for yourself

937
00:05:48,400 --> 00:05:52,690
just to be sure that you understand what's going on before you continue to the

938
00:05:52,690 --> 00:05:53,230
next day.


