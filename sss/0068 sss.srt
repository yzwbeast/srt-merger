1
00:00:00,300 --> 00:00:03,390
All right, guys, welcome to a brand new module.

2
00:00:03,420 --> 00:00:08,640
And in this module, we're going to tackle the topic of authentication.

3
00:00:09,030 --> 00:00:15,290
And it's something that is often thought of as incredibly complicated, but it doesn't have to be.

4
00:00:15,330 --> 00:00:21,750
And we're going to take it step by step from beginning to end so that you get an overview of the entire

5
00:00:21,750 --> 00:00:24,510
process of setting up authentication from scratch.

6
00:00:25,230 --> 00:00:27,610
So why do we need to authenticate?

7
00:00:28,110 --> 00:00:35,730
Well, as we're creating our website or web app for users to use, then these users are going to start

8
00:00:35,730 --> 00:00:38,430
generating data in the website.

9
00:00:38,730 --> 00:00:40,710
They might like certain posts,

10
00:00:40,920 --> 00:00:43,080
they might interact with other users,

11
00:00:43,230 --> 00:00:46,880
there might be messages created or recipes created.

12
00:00:46,920 --> 00:00:49,860
There's always going to be some user data created.

13
00:00:50,400 --> 00:00:57,150
And in order to associate those pieces of data with individual users, we need to create an account

14
00:00:57,150 --> 00:01:02,610
for each user. So that they would sign up to our website using a username and a password

15
00:01:02,910 --> 00:01:09,450
and we would essentially create kind of like an ID card for them to uniquely identify them on our database

16
00:01:09,750 --> 00:01:14,520
and to save all of the data that they generate onto that account.

17
00:01:15,060 --> 00:01:20,670
So the next time that they come back onto the website, they'll be able to use their username and password

18
00:01:21,000 --> 00:01:28,110
and log in to our website and be able to access all of those possibly private pieces of information.

19
00:01:28,470 --> 00:01:33,510
So this way, you don't end up with everybody being able to see, you know, what private messages you're

20
00:01:33,510 --> 00:01:37,280
sending around on Facebook or see your direct messages on Twitter.

21
00:01:37,650 --> 00:01:39,030
So that's pretty simple.

22
00:01:39,270 --> 00:01:45,420
Now, the other reason why you might want to add authentication to your website is to restrict access

23
00:01:45,630 --> 00:01:49,770
to certain areas of the website depending on the status of the user.

24
00:01:50,040 --> 00:01:57,570
So, for example, if you were Spotify or Netflix and you charge a subscription for accessing certain

25
00:01:57,570 --> 00:02:03,210
parts of the website, then once the user pays, you have to update their account in your database to

26
00:02:03,210 --> 00:02:09,930
say that they have paid and they'll be allowed to access the TV shows or songs that they're entitled

27
00:02:09,930 --> 00:02:10,229
to.

28
00:02:10,770 --> 00:02:16,550
So those are some of the reasons why you might want to add authentication to your website.

29
00:02:16,860 --> 00:02:21,030
But authentication can be done in a number of ways.

30
00:02:21,030 --> 00:02:27,690
Creating a website where we sign up and log in users seems simple enough, but the difficult part of

31
00:02:27,690 --> 00:02:32,750
authentication comes from how secure you're going to make your website.

32
00:02:32,840 --> 00:02:38,100
But so we're going to learn how to progress from essentially a website that's basically secured with

33
00:02:38,100 --> 00:02:45,210
a Cheeto to something that is a lot more serious and more consistent with industry standards of good

34
00:02:45,210 --> 00:02:46,810
security on a website.

35
00:02:47,160 --> 00:02:50,600
So the structure of our website is really, really simple.

36
00:02:51,000 --> 00:02:59,760
It has a homepage which has two buttons that allows you to either go towards register or go towards

37
00:02:59,760 --> 00:03:00,300
login.

38
00:03:00,480 --> 00:03:06,120
And once the user has been registered or logged in and they have been authenticated, then they are

39
00:03:06,150 --> 00:03:08,630
able to access the secrets page.

40
00:03:09,150 --> 00:03:15,090
So I've kept the remainder of the website pretty simple because we're going to be focusing on a pretty

41
00:03:15,090 --> 00:03:16,130
complex topic.

42
00:03:16,230 --> 00:03:23,010
So I've created some starting files for you to download so that we can focus our efforts on learning

43
00:03:23,010 --> 00:03:27,160
authentication and not get distracted by things like bootstrap and styling.

44
00:03:27,600 --> 00:03:33,750
So once you're ready, head over to the next lesson and download the starting files, and then we're going

45
00:03:33,750 --> 00:03:35,940
to get started with authentication.

46
00:03:36,270 --> 00:03:37,350
So I'll see you there.


47
00:00:01,230 --> 00:00:08,640
All right, so we've taken a look at level one encryption, which is basically just storing the password

48
00:00:08,640 --> 00:00:11,220
as plain text in our database.

49
00:00:11,370 --> 00:00:18,770
So maybe it'll be a little bit difficult for people to get access to our server and access our database.

50
00:00:18,810 --> 00:00:20,160
At least you can't just simply

51
00:00:20,160 --> 00:00:20,490
right-

52
00:00:20,490 --> 00:00:25,690
click on a website to view page source and be able to see it in the HTML.

53
00:00:25,710 --> 00:00:30,140
At least it's stored at server level. But that's not really good enough.

54
00:00:30,150 --> 00:00:37,150
So let's go ahead and see what we can do to improve the security for our users on our website.

55
00:00:37,470 --> 00:00:47,710
So let's increase to level two authentication. And level two authentication involves the use of encryption.

56
00:00:48,480 --> 00:00:50,520
So what exactly is encryption?

57
00:00:50,550 --> 00:00:57,900
Well, basically all it is is just scrambling something so that people can't tell what the original

58
00:00:57,900 --> 00:01:02,890
was unless they were in on the secret and they knew how to unscramble it.

59
00:01:03,240 --> 00:01:08,610
This is exactly the same as if you and your friend were sending each other secret messages and you had

60
00:01:08,610 --> 00:01:14,010
a key to encode the message that you both knew that so that you could decode the message.

61
00:01:14,970 --> 00:01:21,480
Now, on a bigger scale, if you've ever watched The Imitation Game or read about the Enigma machine,

62
00:01:21,690 --> 00:01:24,750
well, that is basically a form of encryption.

63
00:01:25,230 --> 00:01:31,320
And the Enigma machine, if you don't know, is just simply a machine that was used during World War

64
00:01:31,320 --> 00:01:34,890
2 when the Germans would send each other messages,

65
00:01:35,100 --> 00:01:41,280
they would use the machine to encrypt those messages so that when the messages are intercepted, say,

66
00:01:41,280 --> 00:01:50,220
over the radio, unless you had the same Enigma machine and you knew what the decoding key was or what

67
00:01:50,220 --> 00:01:54,660
the settings were for the machine, then you wouldn't be able to tell what it is that they were trying

68
00:01:54,660 --> 00:01:56,000
to communicate with each other.

69
00:01:56,310 --> 00:02:03,660
If you're interested, I really recommend watching two videos that were done by Numberphile on YouTube and

70
00:02:03,660 --> 00:02:06,210
I've linked to it in the course resources list.

71
00:02:06,540 --> 00:02:14,310
But it explains the Enigma machine and it talks about the flaw in the Enigma machine that led Alan Turing

72
00:02:14,310 --> 00:02:20,760
and other people at Bletchley Park to be able to crack the code and create what was very much a specialized

73
00:02:20,760 --> 00:02:25,920
computer to be able to decode those messages and helped the allies win the war.

74
00:02:26,310 --> 00:02:32,010
And if you ever visit London, be sure to go and check out Bletchley Park and they have a computer museum

75
00:02:32,010 --> 00:02:34,230
next to it as well, which is super fascinating.

76
00:02:34,740 --> 00:02:36,020
Anyways, I digress.

77
00:02:36,030 --> 00:02:36,810
So back to

78
00:02:36,810 --> 00:02:43,590
ciphers and encryption, one of the earliest ways of encrypting messages that we know about is the Caesar

79
00:02:43,590 --> 00:02:44,120
cipher.

80
00:02:44,610 --> 00:02:50,850
And this comes from Julius Caesar, who was one of the generals in the Roman Empire.

81
00:02:51,000 --> 00:02:57,770
And what he did is he would send messages to his generals and he would encrypt it

82
00:02:58,020 --> 00:03:03,330
so if his messenger got murdered along the way, then his messages would be kept secret.

83
00:03:03,990 --> 00:03:09,090
And this is one of the simplest forms of encryption we know about

84
00:03:09,360 --> 00:03:10,550
and it's very simple.

85
00:03:10,560 --> 00:03:16,080
Let's say we have the alphabet, right? ABCDEFG. All that the Caesar Cipher does

86
00:03:16,080 --> 00:03:18,540
is a letter substitution cipher.

87
00:03:18,660 --> 00:03:24,820
And the key for the cipher is the number of letters that you would shift by.

88
00:03:24,870 --> 00:03:31,900
So if you knew what the shift pattern was, then you could really quickly decipher the message.

89
00:03:32,340 --> 00:03:38,210
So if we were to encrypt the word hello, there's a really neat tool online that can help us do that.

90
00:03:38,220 --> 00:03:41,850
It's called cryptii.com and it's got two 'i's at the end.

91
00:03:42,300 --> 00:03:47,760
And you can basically choose the kind of cipher or encryption that you want to use

92
00:03:48,120 --> 00:03:52,550
and then you can specify the shift and we're going to say a shift of three, let's say.

93
00:03:52,800 --> 00:04:00,930
So if my text was hello, then it becomes shifted into khoor. And to an unknowing person and a non-cryptographer,

94
00:04:01,200 --> 00:04:07,950
it can be quite difficult to see at a glance what exactly this is trying to say. Now in modern days and

95
00:04:07,950 --> 00:04:14,010
with modern cryptography, this is overly simplistic and it's very, very easy to crack.

96
00:04:14,460 --> 00:04:20,550
But there are other forms of encryption which are a little bit more complicated and it involves a lot

97
00:04:20,550 --> 00:04:25,380
more math to make it more time consuming for somebody to crack.

98
00:04:25,770 --> 00:04:29,760
But essentially all encryption works exactly the same way.

99
00:04:30,150 --> 00:04:38,730
You have a way of scrambling your message and it requires a key to be able to unscramble that message.

100
00:04:39,450 --> 00:04:39,930
All right.

101
00:04:39,930 --> 00:04:44,520
So now it's time to level up to the next level of security.

102
00:04:44,760 --> 00:04:48,630
And in this lesson, we're going to cover something called hashing.

103
00:04:49,620 --> 00:04:56,910
Now, previously, we've already looked at encryption, so taking the user's password and securing it

104
00:04:56,910 --> 00:05:00,120
using an encryption key, and then 

105
00:05:00,140 --> 00:05:06,560
using a particular cipher method, be it a Caesar cipher or the Enigma cipher, no matter which way

106
00:05:06,560 --> 00:05:12,440
we chose, we always had a password, a key, and we ended up with some ciphertext which will make it

107
00:05:12,440 --> 00:05:16,940
hard for people to be able to immediately guess what our user's password is.

108
00:05:17,120 --> 00:05:23,390
So, for example, if we took a password like qwerty and we use the Caesar cipher method and we decided to

109
00:05:23,390 --> 00:05:27,440
shift it by one, then our encryption key is the number one.

110
00:05:27,860 --> 00:05:32,880
And that creates the ciphertext where every single letter is shifted up by one.

111
00:05:33,350 --> 00:05:39,110
Now, in order to decrypt this, all you have to do, as long as you know what the key is, then you

112
00:05:39,110 --> 00:05:45,980
can simply shift all of the ciphertext down by one and you end up with the original password.

113
00:05:46,340 --> 00:05:51,650
Now, the Caesar cipher is a very, very weak encryption method.

114
00:05:51,650 --> 00:05:58,310
It's incredibly easy to figure out what the original text was, even if you didn't have a key.

115
00:05:58,880 --> 00:06:04,790
And just to illustrate what bad things can happen when you have a weak encryption system, I'm going

116
00:06:04,790 --> 00:06:11,110
to tell you a story from history that tells us why we should not be using a weak encryption system.

117
00:06:11,690 --> 00:06:18,770
So back in the 1500's on this island that we now call the United Kingdom, there used to be two large

118
00:06:18,770 --> 00:06:19,400
areas.

119
00:06:19,670 --> 00:06:23,810
One was Scotland and the other was England.

120
00:06:24,320 --> 00:06:27,080
And they were ruled over by two Queens.

121
00:06:27,380 --> 00:06:33,860
Scotland was ruled by Mary Queen of Scots, who was a Catholic, and England was ruled over by Queen

122
00:06:33,860 --> 00:06:35,210
Elizabeth the first.

123
00:06:35,630 --> 00:06:41,330
Now, these two ladies between them controlled the land that we now call the UK, but they each wanted

124
00:06:41,330 --> 00:06:43,790
to have more power and more land.

125
00:06:44,300 --> 00:06:45,990
So what did they do?

126
00:06:46,010 --> 00:06:53,870
Well, Mary Queen of Scots who ruled over Scotland decided to plot with her friend, Lord Babington,

127
00:06:54,200 --> 00:06:56,800
to try and assassinate Queen Elizabeth.

128
00:06:57,260 --> 00:07:02,720
That way, she would be the legitimate heir to both the English and Scottish throne,

129
00:07:03,050 --> 00:07:06,920
and it was kind of a Game of Thrones kind of situation going on back then.

130
00:07:07,460 --> 00:07:13,910
But in order to mobilize their forces or try to come up with some sort of secret plan, they decided

131
00:07:13,910 --> 00:07:17,800
to send letters to each other using ciphertext.

132
00:07:18,020 --> 00:07:25,850
So they came up with a system to encrypt their letters to each other such that if it fell into the wrong

133
00:07:25,850 --> 00:07:32,800
hands, the subject of the letter wouldn't be revealed and they wouldn't end up being tried for treason.

134
00:07:32,990 --> 00:07:39,260
But the problem was that the encryption method that they used, which was a letter substitution method

135
00:07:39,410 --> 00:07:44,510
similar to the Caesar cipher, was a very weak form of encryption.

136
00:07:45,110 --> 00:07:54,230
And Queen Elizabeth had a chief decoder who ended up deciphering their letters and figuring out what

137
00:07:54,230 --> 00:07:56,220
their encryption key was.

138
00:07:56,420 --> 00:08:04,400
So he decided to take this encryption key and write a letter back to Lord Babington to try and get him

139
00:08:04,400 --> 00:08:07,490
to reveal all of the co-conspirators.

140
00:08:07,880 --> 00:08:11,330
And what was the end result of having their weak encryption system?

141
00:08:11,720 --> 00:08:19,250
Well, Queen Elizabeth decided to accuse Mary Queen of Scots of treason, and hence she ended up having

142
00:08:19,250 --> 00:08:20,360
her head chopped off.

143
00:08:20,750 --> 00:08:25,420
So this is not what you want to happen to you or your website.

144
00:08:25,940 --> 00:08:33,320
So weak encryption systems can end up putting user passwords at risk and your company might end up metaphorically

145
00:08:33,320 --> 00:08:39,230
decapitated, such as in the case of companies like TalkTalk or Equifax, where they ended up getting

146
00:08:39,230 --> 00:08:42,200
hacked and lost a lot of the trust of their users.

147
00:08:42,440 --> 00:08:48,410
Now, if you're interested in more stories like this and to learn more about cryptography and encryption,

148
00:08:48,590 --> 00:08:52,820
there's a really great book recommendation I would make called The Code Book by Simon Singh.

149
00:08:53,000 --> 00:08:56,480
It contains stories like the one that I just told you and more.

150
00:08:56,540 --> 00:08:59,380
So if you're interested in this, go ahead and read more about it.

151
00:08:59,720 --> 00:09:03,500
Now, how can we make our password more secure Now,

152
00:09:03,530 --> 00:09:09,920
at the moment, the biggest flaw in our authentication method is the fact that we need an encryption

153
00:09:09,920 --> 00:09:14,450
key to encrypt our passwords and decrypt our passwords.

154
00:09:14,870 --> 00:09:22,040
And chances are that if somebody is motivated enough to spend time and hack into your database, then

155
00:09:22,040 --> 00:09:29,150
it's probably not that difficult for them to also be able to get your encryption key, even if you've

156
00:09:29,150 --> 00:09:33,480
saved it in environment variable or somewhere secure on your server.

157
00:09:33,950 --> 00:09:38,880
So how can we address this weakest link, the need for that encryption key?

158
00:09:39,140 --> 00:09:45,380
Well, here is where hashing comes into play. Whereas previously with encryption we needed that encryption

159
00:09:45,380 --> 00:09:52,560
key, hashing takes it away and no longer requires the need for an encryption key.

160
00:09:53,180 --> 00:09:59,450
Well, then you might ask, well, if we don't have an encryption key, how can we decrypt our password

161
00:09:59,450 --> 00:09:59,990
back into

162
00:10:00,060 --> 00:10:08,520
plain text? Well, the secret is you don't. Let's say a user registers on our website and they enter

163
00:10:08,520 --> 00:10:16,560
a password to register with, we use something called a hash function to turn that password into a hash

164
00:10:16,560 --> 00:10:19,500
and we store that hash in our database.

165
00:10:20,160 --> 00:10:29,700
Now, the problem is that hash functions are mathematical equations that are designed to make it almost

166
00:10:29,700 --> 00:10:32,280
impossible to go backwards.

167
00:10:32,560 --> 00:10:38,910
So it's almost impossible to turn a hash back into a password.

168
00:10:39,150 --> 00:10:41,130
How is this possible, you might ask?

169
00:10:41,160 --> 00:10:48,690
How is it possible that you can turn a password into a hash very quickly and easily, but make it almost

170
00:10:48,690 --> 00:10:52,080
impossible to turn that hash back into a password?

171
00:10:52,800 --> 00:10:53,880
Well, here's a question.

172
00:10:54,600 --> 00:11:01,710
Let me ask you, what are the factors of 377 other than one and 377?

173
00:11:02,040 --> 00:11:05,650
So basically, I'm saying 377 is not a prime number.

174
00:11:06,090 --> 00:11:14,490
Not only can you divide 377 by 1 and 377, but there's also two other numbers that you

175
00:11:14,490 --> 00:11:15,450
can divide it by.

176
00:11:15,870 --> 00:11:19,260
Now it's your job to figure out what those numbers are.

177
00:11:20,130 --> 00:11:21,420
So, what might you do?

178
00:11:21,450 --> 00:11:23,130
Well, you might divide it by two.

179
00:11:23,490 --> 00:11:26,090
OK, so that becomes 188.5.

180
00:11:26,130 --> 00:11:27,300
That's not a whole number

181
00:11:27,300 --> 00:11:28,880
so 2 is not a factor.

182
00:11:29,280 --> 00:11:30,610
What if you divide it by three?

183
00:11:30,630 --> 00:11:36,290
Well, that becomes 113.3 recurring, which is also not a whole number.

184
00:11:36,450 --> 00:11:38,870
So three is not a factor either.

185
00:11:39,180 --> 00:11:45,940
And you might go through this process for a long time, tediously going through number by number.

186
00:11:45,990 --> 00:11:53,010
Well, then you might arrive at the point where you divide 377 by 13 and you end up with

187
00:11:53,010 --> 00:11:53,680
29.

188
00:11:54,060 --> 00:12:04,140
So 13 and 29 are the answers to this question. They are the only factors of 377 other than 1 and

189
00:12:04,140 --> 00:12:05,000
377.

190
00:12:05,640 --> 00:12:12,750
And as you can see, that process of getting to this point of finding those two factors took us a while,

191
00:12:12,750 --> 00:12:13,130
right?

192
00:12:13,140 --> 00:12:14,400
It wasn't that easy.

193
00:12:14,910 --> 00:12:17,400
But consider if I asked you a different question.

194
00:12:17,400 --> 00:12:20,990
If I said to you, can you multiply 13 by 29?

195
00:12:21,330 --> 00:12:24,900
Well, you would be able to do that really quickly and easily.

196
00:12:24,900 --> 00:12:30,050
It would take you almost no time at all to figure out that the answer is 377.

197
00:12:30,870 --> 00:12:36,880
So here is a very, very simplified version of a hash function.

198
00:12:37,350 --> 00:12:44,790
So going forward, multiplying 13 by 29 is really quick and easy, but going backward, trying

199
00:12:44,790 --> 00:12:46,440
to get back those numbers

200
00:12:46,440 --> 00:12:52,360
13 and 29 starting from 377 is very, very time consuming.

201
00:12:52,770 --> 00:12:56,120
So this is essentially how a hash function works.

202
00:12:56,520 --> 00:13:01,340
Just add a little bit more complexity and you end up with a real hash function.

203
00:13:01,590 --> 00:13:09,360
So they're designed to be calculated very quickly going forwards, but almost impossible to go backward.

204
00:13:09,360 --> 00:13:10,860
And by almost impossible

205
00:13:11,100 --> 00:13:19,110
I simply mean that using current levels of computing power, it would take far too long to make it worthwhile

206
00:13:19,110 --> 00:13:19,810
for the hacker.

207
00:13:20,130 --> 00:13:26,880
So let's say that to calculate the hash going forward, it takes a millisecond, but to go backward

208
00:13:26,880 --> 00:13:31,800
it takes two years, then that hacker probably has better things to do with his time.

209
00:13:31,980 --> 00:13:38,700
So when a user tries to register on our website, then we ask them for the registration password, which

210
00:13:38,700 --> 00:13:44,720
we turn into a hash using our hash function, and then we store that hash on our database.

211
00:13:45,210 --> 00:13:52,020
Now, at a later point when the user tries to log in and they type in their password, then we again

212
00:13:52,110 --> 00:14:00,330
hash that password that they typed in to produce a hash and then we compare it against the hash that

213
00:14:00,330 --> 00:14:02,570
we have stored in our database.

214
00:14:03,060 --> 00:14:10,170
And if those two hashes match, then that must mean that the login password is the same as the registration

215
00:14:10,170 --> 00:14:11,100
password as well.

216
00:14:11,400 --> 00:14:18,810
And at no point in this process do we have to store their password in plain text or are we able to reverse

217
00:14:18,810 --> 00:14:22,350
the process to figure out their original password?

218
00:14:22,710 --> 00:14:26,480
The only person who knows their password is the user themselves.

219
00:14:26,760 --> 00:14:35,400
Now, previously we saw that by using the Enigma machine, as long as we knew what the settings were

220
00:14:35,400 --> 00:14:39,030
for the Enigma machine, which is basically the encryption key,

221
00:14:39,030 --> 00:14:39,360
right?

222
00:14:39,690 --> 00:14:46,800
As long as we knew what that was, then I can decode it by setting it to the same encryption key.

223
00:14:48,270 --> 00:14:55,920
And we end up being able to retrieve the original text. Now, however, if I was to go and change this

224
00:14:56,130 --> 00:15:04,860
to a hash function instead, then you can see that when we try to decode this using the same hash function,

225
00:15:04,860 --> 00:15:06,900
MD5, we get the error

226
00:15:06,900 --> 00:15:12,210
that decoding step is not defined for hash function because you can't really go back.

227
00:15:12,570 --> 00:15:19,310
That's the whole point of the hash function and this is what will make our authentication more secure.


228
00:00:00,210 --> 00:00:00,850
All right, guys.

229
00:00:00,900 --> 00:00:08,340
So now that we've covered creating user passwords, encrypting our database, as well as hashing passwords,

230
00:00:08,730 --> 00:00:14,550
we've kind of reached a level of security that most websites are at.

231
00:00:14,790 --> 00:00:19,170
Now, there's a lot more security that we're going to learn about a little bit later on.

232
00:00:19,710 --> 00:00:25,860
But you're actually at a point where you already know quite a lot about authentication and keeping user

233
00:00:25,860 --> 00:00:31,950
passwords secure, and definitely a lot more than a lot of people who actually run websites.

234
00:00:32,220 --> 00:00:35,720
And I know that some of you guys are keen to get a job.

235
00:00:35,730 --> 00:00:41,520
And if that is you, then I want you to go onto a website called plaintextoffenders.com. I'll

236
00:00:41,520 --> 00:00:43,280
link to it in the course resources.

237
00:00:43,560 --> 00:00:50,880
But here what you'll find is emails that come from various companies where the users requested to reset

238
00:00:50,880 --> 00:00:57,400
their password and they're sending the user a plain text version of their password.

239
00:00:57,690 --> 00:01:03,840
Now, at this point, we know to be able to even get the user's password in plain text, it means that

240
00:01:03,840 --> 00:01:07,830
they're doing some horrible things with securing the passwords.

241
00:01:08,040 --> 00:01:13,920
Either it's encrypted and there's an encryption key somewhere that they're storing or it's simply just

242
00:01:13,920 --> 00:01:18,520
stored on their database as plain text, which is the worst possible type of security.

243
00:01:18,840 --> 00:01:27,030
So given that you already know a lot better than the people who run getlinuxjobs.com or world

244
00:01:27,030 --> 00:01:34,890
sim.com or Telecom Egypt, then you could actually just email these people and tell them that I'm

245
00:01:34,890 --> 00:01:39,650
a web developer and I know about authentication and securing users passwords.

246
00:01:39,660 --> 00:01:41,940
You obviously seem like you might need some help.

247
00:01:42,210 --> 00:01:43,640
Would you like me to work for you?

248
00:01:44,010 --> 00:01:45,990
I recommend giving that a go too

249
00:01:46,020 --> 00:01:50,790
if you're keen on getting a job. If you're not looking for a job, then have a look at these websites.

250
00:01:50,910 --> 00:01:55,410
And if you're signed up to any of them, be sure to delete your account because it's definitely not

251
00:01:55,410 --> 00:01:55,910
secure.

252
00:01:56,070 --> 00:02:03,120
And this is why a lot of companies and a lot of websites get hacked because they don't continue beyond

253
00:02:03,120 --> 00:02:03,690
this point.

254
00:02:04,050 --> 00:02:09,509
So that means it's a really good time to talk to you about how passwords are hacked,

255
00:02:09,690 --> 00:02:13,530
so a sort of hacking Passwords 101 class if you will.

256
00:02:13,830 --> 00:02:16,740
Now, most of the time, I use my programming powers for good.

257
00:02:17,070 --> 00:02:23,100
But in this case, I want to talk to you about how passwords might be hacked so that once we understand

258
00:02:23,190 --> 00:02:29,700
how the other side approaches this problem, then we can learn more about security and make our website

259
00:02:29,710 --> 00:02:30,780
safer for users.

260
00:02:31,200 --> 00:02:36,230
And by the way, I have no idea why hackers are always portrayed in a balaclava.

261
00:02:36,240 --> 00:02:38,760
It's not like they're going to burgle anybody.

262
00:02:39,030 --> 00:02:44,580
I mean, especially this guy, he must be incredibly warm sitting next to all these computers, wearing

263
00:02:44,580 --> 00:02:46,470
so much clothing on his face.

264
00:02:47,130 --> 00:02:48,220
But I digress.

265
00:02:48,600 --> 00:02:55,320
So as a company, this is probably one of the things that you least look forward to. The day when you

266
00:02:55,320 --> 00:02:59,160
wake up and you get a call and you've been hacked.

267
00:02:59,460 --> 00:03:06,300
And this has happened really recently to a lot of big companies like Adobe Creative Cloud got hacked

268
00:03:06,300 --> 00:03:09,510
in 2013, LinkedIn got hacked in 2012.

269
00:03:09,810 --> 00:03:14,150
And there's loads of accounts where their passwords get leaked.

270
00:03:14,430 --> 00:03:21,320
Lots of unhappy users who reuse their passwords and are feeling extremely vulnerable.

271
00:03:21,690 --> 00:03:27,360
And you can see that even to this day, people can purchase these hacked accounts where people might

272
00:03:27,360 --> 00:03:34,200
not have realized that their LinkedIn email and their passwords are linked and people are potentially

273
00:03:34,200 --> 00:03:40,580
buying that data up and using it to hack into their PayPal accounts or other similar payment portals.

274
00:03:40,860 --> 00:03:48,450
So even if you don't learn anything from this lesson, I recommend just going to this website. I'll link

275
00:03:48,450 --> 00:03:52,110
to it in the course resources just for educational purposes.

276
00:03:52,380 --> 00:03:57,540
But put in your email address and make sure that if you do have any passwords that show up, change

277
00:03:57,540 --> 00:03:59,360
all the places where you use that password.

278
00:03:59,520 --> 00:04:05,670
But why is it that all of these big companies are getting hacked and leaking their users passwords?

279
00:04:05,790 --> 00:04:09,120
Are they not at least encrypting or hashing their passwords?

280
00:04:09,690 --> 00:04:10,740
Well, they are.

281
00:04:11,040 --> 00:04:12,150
But consider this.

282
00:04:12,150 --> 00:04:17,850
So you're a hacker and you've managed to get into the LinkedIn user database.

283
00:04:18,300 --> 00:04:21,390
And just for simplicity's sake, let's say it looks like this.

284
00:04:21,390 --> 00:04:23,340
You've got a username and you've got a hash.

285
00:04:23,700 --> 00:04:29,730
And thankfully, they didn't store their users' passwords in plain text, so you can't access their passwords

286
00:04:29,730 --> 00:04:30,330
straight away.

287
00:04:30,900 --> 00:04:39,600
However, if you look at this table a little bit more closely, you will realize that three of the hashes

288
00:04:39,630 --> 00:04:41,880
are completely identical.

289
00:04:42,420 --> 00:04:44,400
Now, why might that be?

290
00:04:44,790 --> 00:04:52,700
Well, remember that the same password always turns into the same hash no matter how often you try it.

291
00:04:52,710 --> 00:04:59,240
And that's a core part of the hash function that we rely on in order to validate our users as well.

292
00:05:00,030 --> 00:05:06,870
That means a hacker would look at this table and realize that Angela, Tony, and Emily all have the same

293
00:05:06,870 --> 00:05:13,190
password, and what they can do is they can start to construct what we call a hash table.

294
00:05:13,500 --> 00:05:20,100
So you would take some of the most commonly used passwords and you would use the same hash function

295
00:05:20,400 --> 00:05:23,290
to create the hash value for each of those.

296
00:05:23,610 --> 00:05:27,810
And these are some of the most common passwords that people love to use.

297
00:05:27,810 --> 00:05:32,280
123456, qwerty, password, 111111.

298
00:05:32,290 --> 00:05:41,100
And so you generate this hash table and then all you have to do is just look up the hash of the user

299
00:05:41,340 --> 00:05:45,120
and compare it against the hash you have in your table.

300
00:05:45,480 --> 00:05:51,660
So you search by the hash value and you land upon the password, which is qwerty.

301
00:05:52,080 --> 00:05:59,140
So now you've figured out that three out of four users in this table all have the same password and it's

302
00:05:59,490 --> 00:05:59,850
qwerty.

303
00:06:00,150 --> 00:06:06,600
So what if they didn't use one of the most common passwords and instead they use something else, say

304
00:06:06,810 --> 00:06:09,450
their date of birth or their pet's name?

305
00:06:09,750 --> 00:06:13,940
Well, let's see how we would make a hash table if we were a hacker.

306
00:06:14,460 --> 00:06:18,330
You would probably start with all the words from a dictionary,

307
00:06:18,510 --> 00:06:21,650
and this is where the term dictionary attack comes from.

308
00:06:21,930 --> 00:06:29,040
You create hashes from all the possible words in a dictionary, and that will only be about 150,000 hashes

309
00:06:29,040 --> 00:06:30,210
that you would need to create.

310
00:06:30,450 --> 00:06:36,170
And then you add to that hash table all the numbers from a telephone book and all the combination of

311
00:06:36,180 --> 00:06:37,950
characters up to six places.

312
00:06:38,220 --> 00:06:45,840
And then you add all of these together and you end up with something close to 19.8 billion

313
00:06:45,840 --> 00:06:50,040
combinations, which admittedly sounds like a large number,

314
00:06:50,040 --> 00:06:50,330
right?

315
00:06:50,340 --> 00:06:54,300
How long would it take your computer to calculate that

316
00:06:54,300 --> 00:06:55,170
many hashes?

317
00:06:55,380 --> 00:06:56,520
So what do we do?

318
00:06:56,550 --> 00:06:58,080
Well, let's go shopping.

319
00:06:58,500 --> 00:07:06,990
Let's go and buy some of the latest GPUs or graphics cards which are capable of parallel processing and

320
00:07:06,990 --> 00:07:14,070
therefore are particularly suited to not only Bitcoin mining, but also generating hashes.

321
00:07:14,340 --> 00:07:23,090
With one of the latest GPS, you can calculate about 20 billion MD5 hashes per second.

322
00:07:23,460 --> 00:07:31,170
So that means with our hash table of 19.8 billion combinations, it'll only take one

323
00:07:31,170 --> 00:07:36,210
of these GPUs 0.9 seconds, which is nothing.

324
00:07:36,600 --> 00:07:41,520
It's not a lot of time to invest in order to hash so many people's passwords.

325
00:07:41,820 --> 00:07:48,730
And to make it even worse, large hash tables have been built for the most common passwords.

326
00:07:49,050 --> 00:07:55,920
So because we've had so much data from previous hacks such as the Adobe one or the LinkedIn one or TalkTalk

327
00:07:55,920 --> 00:08:00,630
or Equifax, we know what the most common passwords are that people use.

328
00:08:00,840 --> 00:08:07,770
And every year companies like Splash Data will compile what are the most common passwords, say the

329
00:08:07,770 --> 00:08:08,910
top 25.

330
00:08:09,240 --> 00:08:12,990
And this is where all of those values that went into our table came from.

331
00:08:13,200 --> 00:08:15,800
But you can actually go one step further.

332
00:08:16,140 --> 00:08:23,790
There are pre-built hash tables that people have created for the top 10,000 most common passwords.

333
00:08:24,180 --> 00:08:28,620
And you can see that MD5 is one of the quickest hashes to calculate.

334
00:08:28,860 --> 00:08:34,470
And this is why it's very, very common to find MD5 hash tables.

335
00:08:34,590 --> 00:08:38,100
And you can even use Google as a basic hash table.

336
00:08:38,429 --> 00:08:42,150
You can paste in the hash that you found from the hacked database.

337
00:08:42,150 --> 00:08:47,500
You perform a simple Google search and you come up with the original password.

338
00:08:48,240 --> 00:08:53,580
Now, if at this point you're extremely scared and you're wondering, well, what exactly can you do

339
00:08:53,580 --> 00:08:54,270
about this?

340
00:08:54,330 --> 00:09:01,680
Well, consider that in our user table, there was one hash that was extremely difficult to find and

341
00:09:01,680 --> 00:09:06,940
it didn't match up with any of the hashes in this little simple hash table we built.

342
00:09:07,140 --> 00:09:14,490
So what if we put that into Google to search on a larger scale and see if it matches any of the hashes

343
00:09:14,730 --> 00:09:17,340
in the hash tables that people have generated?

344
00:09:17,880 --> 00:09:20,210
And it doesn't. It doesn't match anything.

345
00:09:20,490 --> 00:09:27,690
And the reason is because when John created his password, he had a very, very strong password with

346
00:09:27,690 --> 00:09:34,980
uppercase letters, lowercase letters, numbers, symbols, but most importantly, a long password.

347
00:09:35,220 --> 00:09:42,510
When you think about hashing as a mathematical formula, you'll realize that as the number of characters

348
00:09:42,540 --> 00:09:50,130
of your password increases, the computation time that it takes to crack it increases exponentially.

349
00:09:50,290 --> 00:09:57,300
So it doesn't matter if your account on LinkedIn or Adobe  Creative Cloud or Ashley Madison was cracked,

350
00:09:57,570 --> 00:09:59,520
as long as you had a

351
00:09:59,820 --> 00:10:06,300
strong password, they wouldn't be able to work it out from a hash table. So as an example, there's

352
00:10:06,300 --> 00:10:12,330
a website called Password Checker and you can put in your password and it'll tell you not only the strength,

353
00:10:12,600 --> 00:10:18,960
but also how long it will take various types of machines to be able to crack that password.

354
00:10:19,170 --> 00:10:24,660
So let's say that I create a six-character password composed of a random set of characters,

355
00:10:24,660 --> 00:10:27,810
right? 123456.

356
00:10:28,320 --> 00:10:35,460
And you can see that even for a standard desktop PC, it only takes about three seconds to perform a

357
00:10:35,460 --> 00:10:38,510
brute force attack to crack that password.

358
00:10:39,090 --> 00:10:43,500
But let's see what happens if I add another six more characters.

359
00:10:43,920 --> 00:10:47,220
1, 2, 3, 4, 5, 6.

360
00:10:48,440 --> 00:10:57,500
Now, it takes 31 years for a standard desktop PC to be able to crack it and even a fast GPU takes two

361
00:10:57,500 --> 00:10:59,270
years to crack my password.

362
00:10:59,600 --> 00:11:07,400
So even though all of the websites encourage you to add a capital letter, lowercase letter, some numbers

363
00:11:07,400 --> 00:11:14,660
and some random characters, if you only have six characters in your password, so a short password,

364
00:11:14,990 --> 00:11:17,670
it still doesn't take very long to crack.

365
00:11:18,020 --> 00:11:25,910
So the most important thing of creating a strong password that is almost uncrackable is just to increase

366
00:11:25,910 --> 00:11:32,460
the number of characters. And also to prevent yourself from being a victim of a dictionary attack,

367
00:11:32,750 --> 00:11:39,710
just make sure that you don't use a dictionary word or a place name or something that is in a directory

368
00:11:39,710 --> 00:11:41,480
somewhere like a telephone number.

369
00:11:41,930 --> 00:11:42,290
All right.

370
00:11:42,290 --> 00:11:46,180
So at least after this lesson, you'll know how to keep yourself more secure.

371
00:11:46,580 --> 00:11:52,130
But in the next lesson, we're going to address these vulnerabilities that occur because of weak hashing

372
00:11:52,130 --> 00:11:52,760
algorithms,

373
00:11:52,970 --> 00:11:58,790
and we're going to learn how we can combat hackers who try to attack our database using a dictionary

374
00:11:58,790 --> 00:12:00,950
attack or by creating a hash table.

375
00:12:01,250 --> 00:12:04,300
So for all of that and more, I'll see you on the next lesson.

376
00:12:04,460 --> 00:12:09,050
But as a quick bonus, if you ever want to trick your friends into thinking that you're some sort of

377
00:12:09,050 --> 00:12:14,480
a hacker, at least according to Hollywood, I recommend checking out a website called hackertyper

378
00:12:14,480 --> 00:12:21,280
.net where you can just mash the keyboard and you end up with something that looks extremely realistic.

379
00:12:21,290 --> 00:12:26,840
But a word of warning: try not to do this on an airplane or in a government building unless you want to

380
00:12:26,840 --> 00:12:28,380
actually get investigated.


381
00:00:00,690 --> 00:00:06,900
All right, so now that we've seen what some of the vulnerabilities might be for hashed passwords,

382
00:00:06,900 --> 00:00:15,360
it's time to level up and learn about a way that we can prevent these types of dictionary attacks or

383
00:00:15,360 --> 00:00:16,590
hash table cracks.

384
00:00:16,800 --> 00:00:20,260
And in order to do that, we have to learn about salting.

385
00:00:21,150 --> 00:00:23,130
Now, what exactly is salting?

386
00:00:23,370 --> 00:00:26,670
Well, we already know what hashing is. It's

387
00:00:26,670 --> 00:00:33,450
when we take a password, we run it through a hash function and we end up with a hash that we store

388
00:00:33,450 --> 00:00:34,350
on our database.

389
00:00:34,890 --> 00:00:41,220
And as we saw in the last lesson, passwords that are generated by humans are extremely insecure.

390
00:00:41,370 --> 00:00:47,190
They tend to be very short and they tend to be dictionary words that are extremely easy to look up and

391
00:00:47,190 --> 00:00:48,540
create a hash table

392
00:00:48,540 --> 00:00:52,680
for. Now, salting takes hashing a little bit further.

393
00:00:52,890 --> 00:01:01,290
In addition to the password, we also generate a random set of characters, and those characters along

394
00:01:01,290 --> 00:01:06,560
with the user's password gets combined and then put through the hash function.

395
00:01:06,630 --> 00:01:13,470
So the resulting hash is created from both the password as well as that random unique salt.

396
00:01:13,650 --> 00:01:20,400
So that means no matter how simple the password of the user is, adding that salt increases its complexity,

397
00:01:20,400 --> 00:01:26,170
increases the number of characters, and we make our user database a lot more secure.

398
00:01:26,340 --> 00:01:30,360
So consider the previous problem that we saw in the last lesson when

399
00:01:30,600 --> 00:01:32,350
we covered hacking 101.

400
00:01:32,370 --> 00:01:37,860
Now we know that three of our users have the same password and we figured that out because they all

401
00:01:37,860 --> 00:01:38,970
had the same hash.

402
00:01:39,150 --> 00:01:47,790
Now, on the other hand, if we had generated a random set of characters, which is the salt, and combined

403
00:01:47,790 --> 00:01:53,820
the password with the salt in order to generate the hash, then they won't have the same hash in our

404
00:01:53,820 --> 00:01:54,800
user database.

405
00:01:55,020 --> 00:02:01,380
So let's try and generate Emily's hash from her password. So we know that her password is qwerty and

406
00:02:01,380 --> 00:02:02,970
we generate a random salt.

407
00:02:03,150 --> 00:02:06,540
So then let's go ahead and put in her password,

408
00:02:07,020 --> 00:02:14,670
qwerty, and then we append at the end that random salt that we generated and we end up with a hash.

409
00:02:15,510 --> 00:02:24,990
Now this hash, however, is not the same as Tony's hash or Angela's hash because the salt is different

410
00:02:24,990 --> 00:02:25,830
each time.

411
00:02:26,040 --> 00:02:32,760
Now the salt is something that the user doesn't have to remember and instead, it's stored in the database

412
00:02:33,030 --> 00:02:34,410
along with the hash.

413
00:02:34,800 --> 00:02:40,740
So that means when the user types in their password, when they try to log in, you combine their password

414
00:02:40,740 --> 00:02:46,170
with the salt and if you generate the same hash, then they must have had the same password.

415
00:02:46,470 --> 00:02:47,640
It's kind of clever, isn't it?

416
00:02:48,060 --> 00:02:53,670
And on our database, of course, we wouldn't be storing their passwords, but only the salt and the

417
00:02:53,670 --> 00:02:54,190
hash.

418
00:02:54,210 --> 00:02:56,460
Now consider our previous statistics.

419
00:02:56,610 --> 00:03:01,950
You can generate about 20 billion MD5 hashes per second.

420
00:03:02,040 --> 00:03:10,210
So even if we added a salt and we made it harder to generate a hash table, with some of the latest GPUs

421
00:03:10,230 --> 00:03:16,260
you can still probably generate a hash table with all salt combinations relatively quickly.

422
00:03:16,770 --> 00:03:20,040
So what else can we do to increase the security?

423
00:03:20,490 --> 00:03:24,270
Well, we can use something other than MD5, right?

424
00:03:24,510 --> 00:03:30,230
Another hashing algorithm that's valued because it's incredibly slow.

425
00:03:30,780 --> 00:03:32,760
And this is where bscript comes in.

426
00:03:33,210 --> 00:03:40,800
This is one of the industry-standard hashing algorithms that developers use to keep their users' passwords

427
00:03:40,800 --> 00:03:48,720
safe, because while you can calculate 20 billion MD5 hashes per second, even the latest and

428
00:03:48,720 --> 00:03:57,330
the greatest GPUs in 2019 can still calculate only about 17000 bcrypt hashes per second, which makes

429
00:03:57,330 --> 00:04:05,700
it dramatically harder for a hacker to generate those pre-compiled hash tables. And a salted hash table

430
00:04:05,730 --> 00:04:08,220
instead of taking something like three seconds

431
00:04:08,430 --> 00:04:10,230
If it was hashed with MD5,

432
00:04:10,410 --> 00:04:15,780
if it was hash using bcrypt, it would take you something like eight months, which is not really worth

433
00:04:15,780 --> 00:04:16,600
the hacker's while.

434
00:04:16,740 --> 00:04:22,890
They'll probably go and search out a company that has less security enabled. And to make our passwords

435
00:04:22,920 --> 00:04:24,480
even more secure

436
00:04:24,480 --> 00:04:31,170
when we're using bcrypt, it has a concept of what's called salt rounds, how many rounds you're going

437
00:04:31,170 --> 00:04:33,000
to salt your password with.

438
00:04:33,240 --> 00:04:39,090
And obviously the more rounds you do, the saltier your password and also the more secure it is from

439
00:04:39,090 --> 00:04:39,510
hackers.

440
00:04:39,690 --> 00:04:42,110
So, what exactly are salt rounds?

441
00:04:42,420 --> 00:04:50,520
Well, let's say that our original user password was qwerty, and we generate a random set of characters

442
00:04:50,520 --> 00:04:51,450
as the salt.

443
00:04:52,500 --> 00:04:55,350
So now we have qwerty and a random set of salt.

444
00:04:55,800 --> 00:04:59,790
We pass it through our hash function, bcrypt, and we end up with a

445
00:04:59,990 --> 00:05:07,820
hash. Now that one round of salting, if we wanted to have two rounds of salting, then we take the hash

446
00:05:07,820 --> 00:05:13,100
that was generated in round one and we add the same salt from before.

447
00:05:13,580 --> 00:05:19,400
And now we run it through, bcrypt, the hash function again, and we end up with a different hash.

448
00:05:19,970 --> 00:05:24,650
And the number of times you do this is the number of salt rounds.

449
00:05:25,160 --> 00:05:30,630
Now, the reason why this is genius is because as computers get faster...

450
00:05:30,890 --> 00:05:37,730
remember that Moore's Law says that every year the number of transistors in a computer chip almost doubles

451
00:05:37,880 --> 00:05:41,030
and the cost of that faster computer halves.

452
00:05:41,270 --> 00:05:45,200
So every year you can get more computing power for less money.

453
00:05:45,320 --> 00:05:47,330
And this is where salt rounds comes in.

454
00:05:47,480 --> 00:05:54,410
When you're hashing your passwords using bcrypt, you can set the number of rounds you want to salt

455
00:05:54,410 --> 00:05:55,240
your password.

456
00:05:55,340 --> 00:06:02,990
So that means maybe this year in 2019, you salted ten rounds, but maybe next year you can increase that

457
00:06:02,990 --> 00:06:04,270
number to 12.

458
00:06:04,790 --> 00:06:12,080
And for every increase in that number, the amount of time that it takes to hash your password doubles.

459
00:06:12,350 --> 00:06:19,640
And so that means you don't have to change your hashing algorithm or update your code other than simply

460
00:06:19,640 --> 00:06:22,460
changing one number to keep up with the times.

461
00:06:22,700 --> 00:06:30,410
So just to review, coming back to that user database, we'll have each user's username stored, we'll have

462
00:06:30,410 --> 00:06:38,210
their randomly generated salt stored, and then we'll store their hash after a set number of salting

463
00:06:38,210 --> 00:06:38,660
rounds.

464
00:06:40,160 --> 00:06:45,200
And when it comes to checking their password when they login, we'ill take the password that they put

465
00:06:45,200 --> 00:06:51,710
in, combine it with the salt that's stored in the database, and run it through the same number of salting

466
00:06:51,710 --> 00:06:57,980
rounds until we end up with the final hash and we compare the hash against the one that's stored in

467
00:06:57,980 --> 00:07:02,280
the database to see if they've entered the correct password.

468
00:07:02,570 --> 00:07:09,920
So let's give that a go in real life and implement salting rounds into our website's authentication.


